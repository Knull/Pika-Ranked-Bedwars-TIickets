
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Ticket
 * 
 */
export type Ticket = $Result.DefaultSelection<Prisma.$TicketPayload>
/**
 * Model TicketSettings
 * 
 */
export type TicketSettings = $Result.DefaultSelection<Prisma.$TicketSettingsPayload>
/**
 * Model PlayerProfile
 * 
 */
export type PlayerProfile = $Result.DefaultSelection<Prisma.$PlayerProfilePayload>
/**
 * Model TicketConfig
 * 
 */
export type TicketConfig = $Result.DefaultSelection<Prisma.$TicketConfigPayload>
/**
 * Model TicketBlacklist
 * 
 */
export type TicketBlacklist = $Result.DefaultSelection<Prisma.$TicketBlacklistPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Tickets
 * const tickets = await prisma.ticket.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Tickets
   * const tickets = await prisma.ticket.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.ticket`: Exposes CRUD operations for the **Ticket** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tickets
    * const tickets = await prisma.ticket.findMany()
    * ```
    */
  get ticket(): Prisma.TicketDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ticketSettings`: Exposes CRUD operations for the **TicketSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TicketSettings
    * const ticketSettings = await prisma.ticketSettings.findMany()
    * ```
    */
  get ticketSettings(): Prisma.TicketSettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.playerProfile`: Exposes CRUD operations for the **PlayerProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlayerProfiles
    * const playerProfiles = await prisma.playerProfile.findMany()
    * ```
    */
  get playerProfile(): Prisma.PlayerProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ticketConfig`: Exposes CRUD operations for the **TicketConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TicketConfigs
    * const ticketConfigs = await prisma.ticketConfig.findMany()
    * ```
    */
  get ticketConfig(): Prisma.TicketConfigDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ticketBlacklist`: Exposes CRUD operations for the **TicketBlacklist** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TicketBlacklists
    * const ticketBlacklists = await prisma.ticketBlacklist.findMany()
    * ```
    */
  get ticketBlacklist(): Prisma.TicketBlacklistDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.5.0
   * Query Engine version: 173f8d54f8d52e692c7e27e72a88314ec7aeff60
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Ticket: 'Ticket',
    TicketSettings: 'TicketSettings',
    PlayerProfile: 'PlayerProfile',
    TicketConfig: 'TicketConfig',
    TicketBlacklist: 'TicketBlacklist'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "ticket" | "ticketSettings" | "playerProfile" | "ticketConfig" | "ticketBlacklist"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Ticket: {
        payload: Prisma.$TicketPayload<ExtArgs>
        fields: Prisma.TicketFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          findFirst: {
            args: Prisma.TicketFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          findMany: {
            args: Prisma.TicketFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>[]
          }
          create: {
            args: Prisma.TicketCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          createMany: {
            args: Prisma.TicketCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TicketCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>[]
          }
          delete: {
            args: Prisma.TicketDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          update: {
            args: Prisma.TicketUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          deleteMany: {
            args: Prisma.TicketDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TicketUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>[]
          }
          upsert: {
            args: Prisma.TicketUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          aggregate: {
            args: Prisma.TicketAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicket>
          }
          groupBy: {
            args: Prisma.TicketGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketGroupByOutputType>[]
          }
          count: {
            args: Prisma.TicketCountArgs<ExtArgs>
            result: $Utils.Optional<TicketCountAggregateOutputType> | number
          }
        }
      }
      TicketSettings: {
        payload: Prisma.$TicketSettingsPayload<ExtArgs>
        fields: Prisma.TicketSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketSettingsPayload>
          }
          findFirst: {
            args: Prisma.TicketSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketSettingsPayload>
          }
          findMany: {
            args: Prisma.TicketSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketSettingsPayload>[]
          }
          create: {
            args: Prisma.TicketSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketSettingsPayload>
          }
          createMany: {
            args: Prisma.TicketSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TicketSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketSettingsPayload>[]
          }
          delete: {
            args: Prisma.TicketSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketSettingsPayload>
          }
          update: {
            args: Prisma.TicketSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketSettingsPayload>
          }
          deleteMany: {
            args: Prisma.TicketSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TicketSettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketSettingsPayload>[]
          }
          upsert: {
            args: Prisma.TicketSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketSettingsPayload>
          }
          aggregate: {
            args: Prisma.TicketSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicketSettings>
          }
          groupBy: {
            args: Prisma.TicketSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.TicketSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<TicketSettingsCountAggregateOutputType> | number
          }
        }
      }
      PlayerProfile: {
        payload: Prisma.$PlayerProfilePayload<ExtArgs>
        fields: Prisma.PlayerProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlayerProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlayerProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerProfilePayload>
          }
          findFirst: {
            args: Prisma.PlayerProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlayerProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerProfilePayload>
          }
          findMany: {
            args: Prisma.PlayerProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerProfilePayload>[]
          }
          create: {
            args: Prisma.PlayerProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerProfilePayload>
          }
          createMany: {
            args: Prisma.PlayerProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlayerProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerProfilePayload>[]
          }
          delete: {
            args: Prisma.PlayerProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerProfilePayload>
          }
          update: {
            args: Prisma.PlayerProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerProfilePayload>
          }
          deleteMany: {
            args: Prisma.PlayerProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlayerProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlayerProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerProfilePayload>[]
          }
          upsert: {
            args: Prisma.PlayerProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerProfilePayload>
          }
          aggregate: {
            args: Prisma.PlayerProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlayerProfile>
          }
          groupBy: {
            args: Prisma.PlayerProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlayerProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlayerProfileCountArgs<ExtArgs>
            result: $Utils.Optional<PlayerProfileCountAggregateOutputType> | number
          }
        }
      }
      TicketConfig: {
        payload: Prisma.$TicketConfigPayload<ExtArgs>
        fields: Prisma.TicketConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketConfigPayload>
          }
          findFirst: {
            args: Prisma.TicketConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketConfigPayload>
          }
          findMany: {
            args: Prisma.TicketConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketConfigPayload>[]
          }
          create: {
            args: Prisma.TicketConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketConfigPayload>
          }
          createMany: {
            args: Prisma.TicketConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TicketConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketConfigPayload>[]
          }
          delete: {
            args: Prisma.TicketConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketConfigPayload>
          }
          update: {
            args: Prisma.TicketConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketConfigPayload>
          }
          deleteMany: {
            args: Prisma.TicketConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TicketConfigUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketConfigPayload>[]
          }
          upsert: {
            args: Prisma.TicketConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketConfigPayload>
          }
          aggregate: {
            args: Prisma.TicketConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicketConfig>
          }
          groupBy: {
            args: Prisma.TicketConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.TicketConfigCountArgs<ExtArgs>
            result: $Utils.Optional<TicketConfigCountAggregateOutputType> | number
          }
        }
      }
      TicketBlacklist: {
        payload: Prisma.$TicketBlacklistPayload<ExtArgs>
        fields: Prisma.TicketBlacklistFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketBlacklistFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketBlacklistPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketBlacklistFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketBlacklistPayload>
          }
          findFirst: {
            args: Prisma.TicketBlacklistFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketBlacklistPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketBlacklistFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketBlacklistPayload>
          }
          findMany: {
            args: Prisma.TicketBlacklistFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketBlacklistPayload>[]
          }
          create: {
            args: Prisma.TicketBlacklistCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketBlacklistPayload>
          }
          createMany: {
            args: Prisma.TicketBlacklistCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TicketBlacklistCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketBlacklistPayload>[]
          }
          delete: {
            args: Prisma.TicketBlacklistDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketBlacklistPayload>
          }
          update: {
            args: Prisma.TicketBlacklistUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketBlacklistPayload>
          }
          deleteMany: {
            args: Prisma.TicketBlacklistDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketBlacklistUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TicketBlacklistUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketBlacklistPayload>[]
          }
          upsert: {
            args: Prisma.TicketBlacklistUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketBlacklistPayload>
          }
          aggregate: {
            args: Prisma.TicketBlacklistAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicketBlacklist>
          }
          groupBy: {
            args: Prisma.TicketBlacklistGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketBlacklistGroupByOutputType>[]
          }
          count: {
            args: Prisma.TicketBlacklistCountArgs<ExtArgs>
            result: $Utils.Optional<TicketBlacklistCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    ticket?: TicketOmit
    ticketSettings?: TicketSettingsOmit
    playerProfile?: PlayerProfileOmit
    ticketConfig?: TicketConfigOmit
    ticketBlacklist?: TicketBlacklistOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */



  /**
   * Models
   */

  /**
   * Model Ticket
   */

  export type AggregateTicket = {
    _count: TicketCountAggregateOutputType | null
    _avg: TicketAvgAggregateOutputType | null
    _sum: TicketSumAggregateOutputType | null
    _min: TicketMinAggregateOutputType | null
    _max: TicketMaxAggregateOutputType | null
  }

  export type TicketAvgAggregateOutputType = {
    id: number | null
    ticketNumber: number | null
    duration: number | null
  }

  export type TicketSumAggregateOutputType = {
    id: number | null
    ticketNumber: number | null
    duration: number | null
  }

  export type TicketMinAggregateOutputType = {
    id: number | null
    ticketNumber: number | null
    ticketType: string | null
    status: string | null
    channelId: string | null
    userId: string | null
    ticketMessageId: string | null
    reason: string | null
    reportedUser: string | null
    inviteLink: string | null
    transcriptUrl: string | null
    lastMessageAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    duration: number | null
    outsideMessageId: string | null
  }

  export type TicketMaxAggregateOutputType = {
    id: number | null
    ticketNumber: number | null
    ticketType: string | null
    status: string | null
    channelId: string | null
    userId: string | null
    ticketMessageId: string | null
    reason: string | null
    reportedUser: string | null
    inviteLink: string | null
    transcriptUrl: string | null
    lastMessageAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    duration: number | null
    outsideMessageId: string | null
  }

  export type TicketCountAggregateOutputType = {
    id: number
    ticketNumber: number
    ticketType: number
    status: number
    channelId: number
    userId: number
    ticketMessageId: number
    reason: number
    reportedUser: number
    inviteLink: number
    proofUrls: number
    transcriptUrl: number
    lastMessageAt: number
    createdAt: number
    updatedAt: number
    added_user: number
    added_roles: number
    duration: number
    outsideMessageId: number
    _all: number
  }


  export type TicketAvgAggregateInputType = {
    id?: true
    ticketNumber?: true
    duration?: true
  }

  export type TicketSumAggregateInputType = {
    id?: true
    ticketNumber?: true
    duration?: true
  }

  export type TicketMinAggregateInputType = {
    id?: true
    ticketNumber?: true
    ticketType?: true
    status?: true
    channelId?: true
    userId?: true
    ticketMessageId?: true
    reason?: true
    reportedUser?: true
    inviteLink?: true
    transcriptUrl?: true
    lastMessageAt?: true
    createdAt?: true
    updatedAt?: true
    duration?: true
    outsideMessageId?: true
  }

  export type TicketMaxAggregateInputType = {
    id?: true
    ticketNumber?: true
    ticketType?: true
    status?: true
    channelId?: true
    userId?: true
    ticketMessageId?: true
    reason?: true
    reportedUser?: true
    inviteLink?: true
    transcriptUrl?: true
    lastMessageAt?: true
    createdAt?: true
    updatedAt?: true
    duration?: true
    outsideMessageId?: true
  }

  export type TicketCountAggregateInputType = {
    id?: true
    ticketNumber?: true
    ticketType?: true
    status?: true
    channelId?: true
    userId?: true
    ticketMessageId?: true
    reason?: true
    reportedUser?: true
    inviteLink?: true
    proofUrls?: true
    transcriptUrl?: true
    lastMessageAt?: true
    createdAt?: true
    updatedAt?: true
    added_user?: true
    added_roles?: true
    duration?: true
    outsideMessageId?: true
    _all?: true
  }

  export type TicketAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ticket to aggregate.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tickets
    **/
    _count?: true | TicketCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TicketAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TicketSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketMaxAggregateInputType
  }

  export type GetTicketAggregateType<T extends TicketAggregateArgs> = {
        [P in keyof T & keyof AggregateTicket]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicket[P]>
      : GetScalarType<T[P], AggregateTicket[P]>
  }




  export type TicketGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithAggregationInput | TicketOrderByWithAggregationInput[]
    by: TicketScalarFieldEnum[] | TicketScalarFieldEnum
    having?: TicketScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketCountAggregateInputType | true
    _avg?: TicketAvgAggregateInputType
    _sum?: TicketSumAggregateInputType
    _min?: TicketMinAggregateInputType
    _max?: TicketMaxAggregateInputType
  }

  export type TicketGroupByOutputType = {
    id: number
    ticketNumber: number
    ticketType: string
    status: string
    channelId: string
    userId: string
    ticketMessageId: string | null
    reason: string | null
    reportedUser: string | null
    inviteLink: string | null
    proofUrls: JsonValue | null
    transcriptUrl: string | null
    lastMessageAt: Date | null
    createdAt: Date
    updatedAt: Date
    added_user: JsonValue | null
    added_roles: JsonValue | null
    duration: number | null
    outsideMessageId: string | null
    _count: TicketCountAggregateOutputType | null
    _avg: TicketAvgAggregateOutputType | null
    _sum: TicketSumAggregateOutputType | null
    _min: TicketMinAggregateOutputType | null
    _max: TicketMaxAggregateOutputType | null
  }

  type GetTicketGroupByPayload<T extends TicketGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketGroupByOutputType[P]>
            : GetScalarType<T[P], TicketGroupByOutputType[P]>
        }
      >
    >


  export type TicketSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketNumber?: boolean
    ticketType?: boolean
    status?: boolean
    channelId?: boolean
    userId?: boolean
    ticketMessageId?: boolean
    reason?: boolean
    reportedUser?: boolean
    inviteLink?: boolean
    proofUrls?: boolean
    transcriptUrl?: boolean
    lastMessageAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    added_user?: boolean
    added_roles?: boolean
    duration?: boolean
    outsideMessageId?: boolean
  }, ExtArgs["result"]["ticket"]>

  export type TicketSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketNumber?: boolean
    ticketType?: boolean
    status?: boolean
    channelId?: boolean
    userId?: boolean
    ticketMessageId?: boolean
    reason?: boolean
    reportedUser?: boolean
    inviteLink?: boolean
    proofUrls?: boolean
    transcriptUrl?: boolean
    lastMessageAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    added_user?: boolean
    added_roles?: boolean
    duration?: boolean
    outsideMessageId?: boolean
  }, ExtArgs["result"]["ticket"]>

  export type TicketSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketNumber?: boolean
    ticketType?: boolean
    status?: boolean
    channelId?: boolean
    userId?: boolean
    ticketMessageId?: boolean
    reason?: boolean
    reportedUser?: boolean
    inviteLink?: boolean
    proofUrls?: boolean
    transcriptUrl?: boolean
    lastMessageAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    added_user?: boolean
    added_roles?: boolean
    duration?: boolean
    outsideMessageId?: boolean
  }, ExtArgs["result"]["ticket"]>

  export type TicketSelectScalar = {
    id?: boolean
    ticketNumber?: boolean
    ticketType?: boolean
    status?: boolean
    channelId?: boolean
    userId?: boolean
    ticketMessageId?: boolean
    reason?: boolean
    reportedUser?: boolean
    inviteLink?: boolean
    proofUrls?: boolean
    transcriptUrl?: boolean
    lastMessageAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    added_user?: boolean
    added_roles?: boolean
    duration?: boolean
    outsideMessageId?: boolean
  }

  export type TicketOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ticketNumber" | "ticketType" | "status" | "channelId" | "userId" | "ticketMessageId" | "reason" | "reportedUser" | "inviteLink" | "proofUrls" | "transcriptUrl" | "lastMessageAt" | "createdAt" | "updatedAt" | "added_user" | "added_roles" | "duration" | "outsideMessageId", ExtArgs["result"]["ticket"]>

  export type $TicketPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ticket"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      ticketNumber: number
      ticketType: string
      status: string
      channelId: string
      userId: string
      ticketMessageId: string | null
      reason: string | null
      reportedUser: string | null
      inviteLink: string | null
      proofUrls: Prisma.JsonValue | null
      transcriptUrl: string | null
      lastMessageAt: Date | null
      createdAt: Date
      updatedAt: Date
      added_user: Prisma.JsonValue | null
      added_roles: Prisma.JsonValue | null
      duration: number | null
      outsideMessageId: string | null
    }, ExtArgs["result"]["ticket"]>
    composites: {}
  }

  type TicketGetPayload<S extends boolean | null | undefined | TicketDefaultArgs> = $Result.GetResult<Prisma.$TicketPayload, S>

  type TicketCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TicketFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TicketCountAggregateInputType | true
    }

  export interface TicketDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ticket'], meta: { name: 'Ticket' } }
    /**
     * Find zero or one Ticket that matches the filter.
     * @param {TicketFindUniqueArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketFindUniqueArgs>(args: SelectSubset<T, TicketFindUniqueArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ticket that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TicketFindUniqueOrThrowArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ticket that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindFirstArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketFindFirstArgs>(args?: SelectSubset<T, TicketFindFirstArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ticket that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindFirstOrThrowArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tickets
     * const tickets = await prisma.ticket.findMany()
     * 
     * // Get first 10 Tickets
     * const tickets = await prisma.ticket.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketWithIdOnly = await prisma.ticket.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketFindManyArgs>(args?: SelectSubset<T, TicketFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ticket.
     * @param {TicketCreateArgs} args - Arguments to create a Ticket.
     * @example
     * // Create one Ticket
     * const Ticket = await prisma.ticket.create({
     *   data: {
     *     // ... data to create a Ticket
     *   }
     * })
     * 
     */
    create<T extends TicketCreateArgs>(args: SelectSubset<T, TicketCreateArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tickets.
     * @param {TicketCreateManyArgs} args - Arguments to create many Tickets.
     * @example
     * // Create many Tickets
     * const ticket = await prisma.ticket.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketCreateManyArgs>(args?: SelectSubset<T, TicketCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tickets and returns the data saved in the database.
     * @param {TicketCreateManyAndReturnArgs} args - Arguments to create many Tickets.
     * @example
     * // Create many Tickets
     * const ticket = await prisma.ticket.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tickets and only return the `id`
     * const ticketWithIdOnly = await prisma.ticket.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TicketCreateManyAndReturnArgs>(args?: SelectSubset<T, TicketCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ticket.
     * @param {TicketDeleteArgs} args - Arguments to delete one Ticket.
     * @example
     * // Delete one Ticket
     * const Ticket = await prisma.ticket.delete({
     *   where: {
     *     // ... filter to delete one Ticket
     *   }
     * })
     * 
     */
    delete<T extends TicketDeleteArgs>(args: SelectSubset<T, TicketDeleteArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ticket.
     * @param {TicketUpdateArgs} args - Arguments to update one Ticket.
     * @example
     * // Update one Ticket
     * const ticket = await prisma.ticket.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketUpdateArgs>(args: SelectSubset<T, TicketUpdateArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tickets.
     * @param {TicketDeleteManyArgs} args - Arguments to filter Tickets to delete.
     * @example
     * // Delete a few Tickets
     * const { count } = await prisma.ticket.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketDeleteManyArgs>(args?: SelectSubset<T, TicketDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tickets
     * const ticket = await prisma.ticket.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketUpdateManyArgs>(args: SelectSubset<T, TicketUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tickets and returns the data updated in the database.
     * @param {TicketUpdateManyAndReturnArgs} args - Arguments to update many Tickets.
     * @example
     * // Update many Tickets
     * const ticket = await prisma.ticket.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tickets and only return the `id`
     * const ticketWithIdOnly = await prisma.ticket.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TicketUpdateManyAndReturnArgs>(args: SelectSubset<T, TicketUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ticket.
     * @param {TicketUpsertArgs} args - Arguments to update or create a Ticket.
     * @example
     * // Update or create a Ticket
     * const ticket = await prisma.ticket.upsert({
     *   create: {
     *     // ... data to create a Ticket
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ticket we want to update
     *   }
     * })
     */
    upsert<T extends TicketUpsertArgs>(args: SelectSubset<T, TicketUpsertArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCountArgs} args - Arguments to filter Tickets to count.
     * @example
     * // Count the number of Tickets
     * const count = await prisma.ticket.count({
     *   where: {
     *     // ... the filter for the Tickets we want to count
     *   }
     * })
    **/
    count<T extends TicketCountArgs>(
      args?: Subset<T, TicketCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ticket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketAggregateArgs>(args: Subset<T, TicketAggregateArgs>): Prisma.PrismaPromise<GetTicketAggregateType<T>>

    /**
     * Group by Ticket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketGroupByArgs['orderBy'] }
        : { orderBy?: TicketGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ticket model
   */
  readonly fields: TicketFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ticket.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ticket model
   */ 
  interface TicketFieldRefs {
    readonly id: FieldRef<"Ticket", 'Int'>
    readonly ticketNumber: FieldRef<"Ticket", 'Int'>
    readonly ticketType: FieldRef<"Ticket", 'String'>
    readonly status: FieldRef<"Ticket", 'String'>
    readonly channelId: FieldRef<"Ticket", 'String'>
    readonly userId: FieldRef<"Ticket", 'String'>
    readonly ticketMessageId: FieldRef<"Ticket", 'String'>
    readonly reason: FieldRef<"Ticket", 'String'>
    readonly reportedUser: FieldRef<"Ticket", 'String'>
    readonly inviteLink: FieldRef<"Ticket", 'String'>
    readonly proofUrls: FieldRef<"Ticket", 'Json'>
    readonly transcriptUrl: FieldRef<"Ticket", 'String'>
    readonly lastMessageAt: FieldRef<"Ticket", 'DateTime'>
    readonly createdAt: FieldRef<"Ticket", 'DateTime'>
    readonly updatedAt: FieldRef<"Ticket", 'DateTime'>
    readonly added_user: FieldRef<"Ticket", 'Json'>
    readonly added_roles: FieldRef<"Ticket", 'Json'>
    readonly duration: FieldRef<"Ticket", 'Int'>
    readonly outsideMessageId: FieldRef<"Ticket", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Ticket findUnique
   */
  export type TicketFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket findUniqueOrThrow
   */
  export type TicketFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket findFirst
   */
  export type TicketFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tickets.
     */
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Ticket findFirstOrThrow
   */
  export type TicketFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tickets.
     */
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Ticket findMany
   */
  export type TicketFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Filter, which Tickets to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Ticket create
   */
  export type TicketCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * The data needed to create a Ticket.
     */
    data: XOR<TicketCreateInput, TicketUncheckedCreateInput>
  }

  /**
   * Ticket createMany
   */
  export type TicketCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tickets.
     */
    data: TicketCreateManyInput | TicketCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ticket createManyAndReturn
   */
  export type TicketCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * The data used to create many Tickets.
     */
    data: TicketCreateManyInput | TicketCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ticket update
   */
  export type TicketUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * The data needed to update a Ticket.
     */
    data: XOR<TicketUpdateInput, TicketUncheckedUpdateInput>
    /**
     * Choose, which Ticket to update.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket updateMany
   */
  export type TicketUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tickets.
     */
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyInput>
    /**
     * Filter which Tickets to update
     */
    where?: TicketWhereInput
    /**
     * Limit how many Tickets to update.
     */
    limit?: number
  }

  /**
   * Ticket updateManyAndReturn
   */
  export type TicketUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * The data used to update Tickets.
     */
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyInput>
    /**
     * Filter which Tickets to update
     */
    where?: TicketWhereInput
    /**
     * Limit how many Tickets to update.
     */
    limit?: number
  }

  /**
   * Ticket upsert
   */
  export type TicketUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * The filter to search for the Ticket to update in case it exists.
     */
    where: TicketWhereUniqueInput
    /**
     * In case the Ticket found by the `where` argument doesn't exist, create a new Ticket with this data.
     */
    create: XOR<TicketCreateInput, TicketUncheckedCreateInput>
    /**
     * In case the Ticket was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketUpdateInput, TicketUncheckedUpdateInput>
  }

  /**
   * Ticket delete
   */
  export type TicketDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Filter which Ticket to delete.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket deleteMany
   */
  export type TicketDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tickets to delete
     */
    where?: TicketWhereInput
    /**
     * Limit how many Tickets to delete.
     */
    limit?: number
  }

  /**
   * Ticket without action
   */
  export type TicketDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
  }


  /**
   * Model TicketSettings
   */

  export type AggregateTicketSettings = {
    _count: TicketSettingsCountAggregateOutputType | null
    _avg: TicketSettingsAvgAggregateOutputType | null
    _sum: TicketSettingsSumAggregateOutputType | null
    _min: TicketSettingsMinAggregateOutputType | null
    _max: TicketSettingsMaxAggregateOutputType | null
  }

  export type TicketSettingsAvgAggregateOutputType = {
    id: number | null
    ticketCounter: number | null
  }

  export type TicketSettingsSumAggregateOutputType = {
    id: number | null
    ticketCounter: number | null
  }

  export type TicketSettingsMinAggregateOutputType = {
    id: number | null
    ticketCounter: number | null
  }

  export type TicketSettingsMaxAggregateOutputType = {
    id: number | null
    ticketCounter: number | null
  }

  export type TicketSettingsCountAggregateOutputType = {
    id: number
    ticketCounter: number
    _all: number
  }


  export type TicketSettingsAvgAggregateInputType = {
    id?: true
    ticketCounter?: true
  }

  export type TicketSettingsSumAggregateInputType = {
    id?: true
    ticketCounter?: true
  }

  export type TicketSettingsMinAggregateInputType = {
    id?: true
    ticketCounter?: true
  }

  export type TicketSettingsMaxAggregateInputType = {
    id?: true
    ticketCounter?: true
  }

  export type TicketSettingsCountAggregateInputType = {
    id?: true
    ticketCounter?: true
    _all?: true
  }

  export type TicketSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketSettings to aggregate.
     */
    where?: TicketSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketSettings to fetch.
     */
    orderBy?: TicketSettingsOrderByWithRelationInput | TicketSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TicketSettings
    **/
    _count?: true | TicketSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TicketSettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TicketSettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketSettingsMaxAggregateInputType
  }

  export type GetTicketSettingsAggregateType<T extends TicketSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateTicketSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicketSettings[P]>
      : GetScalarType<T[P], AggregateTicketSettings[P]>
  }




  export type TicketSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketSettingsWhereInput
    orderBy?: TicketSettingsOrderByWithAggregationInput | TicketSettingsOrderByWithAggregationInput[]
    by: TicketSettingsScalarFieldEnum[] | TicketSettingsScalarFieldEnum
    having?: TicketSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketSettingsCountAggregateInputType | true
    _avg?: TicketSettingsAvgAggregateInputType
    _sum?: TicketSettingsSumAggregateInputType
    _min?: TicketSettingsMinAggregateInputType
    _max?: TicketSettingsMaxAggregateInputType
  }

  export type TicketSettingsGroupByOutputType = {
    id: number
    ticketCounter: number
    _count: TicketSettingsCountAggregateOutputType | null
    _avg: TicketSettingsAvgAggregateOutputType | null
    _sum: TicketSettingsSumAggregateOutputType | null
    _min: TicketSettingsMinAggregateOutputType | null
    _max: TicketSettingsMaxAggregateOutputType | null
  }

  type GetTicketSettingsGroupByPayload<T extends TicketSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], TicketSettingsGroupByOutputType[P]>
        }
      >
    >


  export type TicketSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketCounter?: boolean
  }, ExtArgs["result"]["ticketSettings"]>

  export type TicketSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketCounter?: boolean
  }, ExtArgs["result"]["ticketSettings"]>

  export type TicketSettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketCounter?: boolean
  }, ExtArgs["result"]["ticketSettings"]>

  export type TicketSettingsSelectScalar = {
    id?: boolean
    ticketCounter?: boolean
  }

  export type TicketSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ticketCounter", ExtArgs["result"]["ticketSettings"]>

  export type $TicketSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TicketSettings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      ticketCounter: number
    }, ExtArgs["result"]["ticketSettings"]>
    composites: {}
  }

  type TicketSettingsGetPayload<S extends boolean | null | undefined | TicketSettingsDefaultArgs> = $Result.GetResult<Prisma.$TicketSettingsPayload, S>

  type TicketSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TicketSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TicketSettingsCountAggregateInputType | true
    }

  export interface TicketSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TicketSettings'], meta: { name: 'TicketSettings' } }
    /**
     * Find zero or one TicketSettings that matches the filter.
     * @param {TicketSettingsFindUniqueArgs} args - Arguments to find a TicketSettings
     * @example
     * // Get one TicketSettings
     * const ticketSettings = await prisma.ticketSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketSettingsFindUniqueArgs>(args: SelectSubset<T, TicketSettingsFindUniqueArgs<ExtArgs>>): Prisma__TicketSettingsClient<$Result.GetResult<Prisma.$TicketSettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TicketSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TicketSettingsFindUniqueOrThrowArgs} args - Arguments to find a TicketSettings
     * @example
     * // Get one TicketSettings
     * const ticketSettings = await prisma.ticketSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketSettingsClient<$Result.GetResult<Prisma.$TicketSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TicketSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketSettingsFindFirstArgs} args - Arguments to find a TicketSettings
     * @example
     * // Get one TicketSettings
     * const ticketSettings = await prisma.ticketSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketSettingsFindFirstArgs>(args?: SelectSubset<T, TicketSettingsFindFirstArgs<ExtArgs>>): Prisma__TicketSettingsClient<$Result.GetResult<Prisma.$TicketSettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TicketSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketSettingsFindFirstOrThrowArgs} args - Arguments to find a TicketSettings
     * @example
     * // Get one TicketSettings
     * const ticketSettings = await prisma.ticketSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketSettingsClient<$Result.GetResult<Prisma.$TicketSettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TicketSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TicketSettings
     * const ticketSettings = await prisma.ticketSettings.findMany()
     * 
     * // Get first 10 TicketSettings
     * const ticketSettings = await prisma.ticketSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketSettingsWithIdOnly = await prisma.ticketSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketSettingsFindManyArgs>(args?: SelectSubset<T, TicketSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TicketSettings.
     * @param {TicketSettingsCreateArgs} args - Arguments to create a TicketSettings.
     * @example
     * // Create one TicketSettings
     * const TicketSettings = await prisma.ticketSettings.create({
     *   data: {
     *     // ... data to create a TicketSettings
     *   }
     * })
     * 
     */
    create<T extends TicketSettingsCreateArgs>(args: SelectSubset<T, TicketSettingsCreateArgs<ExtArgs>>): Prisma__TicketSettingsClient<$Result.GetResult<Prisma.$TicketSettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TicketSettings.
     * @param {TicketSettingsCreateManyArgs} args - Arguments to create many TicketSettings.
     * @example
     * // Create many TicketSettings
     * const ticketSettings = await prisma.ticketSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketSettingsCreateManyArgs>(args?: SelectSubset<T, TicketSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TicketSettings and returns the data saved in the database.
     * @param {TicketSettingsCreateManyAndReturnArgs} args - Arguments to create many TicketSettings.
     * @example
     * // Create many TicketSettings
     * const ticketSettings = await prisma.ticketSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TicketSettings and only return the `id`
     * const ticketSettingsWithIdOnly = await prisma.ticketSettings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TicketSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, TicketSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketSettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TicketSettings.
     * @param {TicketSettingsDeleteArgs} args - Arguments to delete one TicketSettings.
     * @example
     * // Delete one TicketSettings
     * const TicketSettings = await prisma.ticketSettings.delete({
     *   where: {
     *     // ... filter to delete one TicketSettings
     *   }
     * })
     * 
     */
    delete<T extends TicketSettingsDeleteArgs>(args: SelectSubset<T, TicketSettingsDeleteArgs<ExtArgs>>): Prisma__TicketSettingsClient<$Result.GetResult<Prisma.$TicketSettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TicketSettings.
     * @param {TicketSettingsUpdateArgs} args - Arguments to update one TicketSettings.
     * @example
     * // Update one TicketSettings
     * const ticketSettings = await prisma.ticketSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketSettingsUpdateArgs>(args: SelectSubset<T, TicketSettingsUpdateArgs<ExtArgs>>): Prisma__TicketSettingsClient<$Result.GetResult<Prisma.$TicketSettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TicketSettings.
     * @param {TicketSettingsDeleteManyArgs} args - Arguments to filter TicketSettings to delete.
     * @example
     * // Delete a few TicketSettings
     * const { count } = await prisma.ticketSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketSettingsDeleteManyArgs>(args?: SelectSubset<T, TicketSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TicketSettings
     * const ticketSettings = await prisma.ticketSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketSettingsUpdateManyArgs>(args: SelectSubset<T, TicketSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketSettings and returns the data updated in the database.
     * @param {TicketSettingsUpdateManyAndReturnArgs} args - Arguments to update many TicketSettings.
     * @example
     * // Update many TicketSettings
     * const ticketSettings = await prisma.ticketSettings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TicketSettings and only return the `id`
     * const ticketSettingsWithIdOnly = await prisma.ticketSettings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TicketSettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, TicketSettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketSettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TicketSettings.
     * @param {TicketSettingsUpsertArgs} args - Arguments to update or create a TicketSettings.
     * @example
     * // Update or create a TicketSettings
     * const ticketSettings = await prisma.ticketSettings.upsert({
     *   create: {
     *     // ... data to create a TicketSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TicketSettings we want to update
     *   }
     * })
     */
    upsert<T extends TicketSettingsUpsertArgs>(args: SelectSubset<T, TicketSettingsUpsertArgs<ExtArgs>>): Prisma__TicketSettingsClient<$Result.GetResult<Prisma.$TicketSettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TicketSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketSettingsCountArgs} args - Arguments to filter TicketSettings to count.
     * @example
     * // Count the number of TicketSettings
     * const count = await prisma.ticketSettings.count({
     *   where: {
     *     // ... the filter for the TicketSettings we want to count
     *   }
     * })
    **/
    count<T extends TicketSettingsCountArgs>(
      args?: Subset<T, TicketSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TicketSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketSettingsAggregateArgs>(args: Subset<T, TicketSettingsAggregateArgs>): Prisma.PrismaPromise<GetTicketSettingsAggregateType<T>>

    /**
     * Group by TicketSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketSettingsGroupByArgs['orderBy'] }
        : { orderBy?: TicketSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TicketSettings model
   */
  readonly fields: TicketSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TicketSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TicketSettings model
   */ 
  interface TicketSettingsFieldRefs {
    readonly id: FieldRef<"TicketSettings", 'Int'>
    readonly ticketCounter: FieldRef<"TicketSettings", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TicketSettings findUnique
   */
  export type TicketSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketSettings
     */
    select?: TicketSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketSettings
     */
    omit?: TicketSettingsOmit<ExtArgs> | null
    /**
     * Filter, which TicketSettings to fetch.
     */
    where: TicketSettingsWhereUniqueInput
  }

  /**
   * TicketSettings findUniqueOrThrow
   */
  export type TicketSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketSettings
     */
    select?: TicketSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketSettings
     */
    omit?: TicketSettingsOmit<ExtArgs> | null
    /**
     * Filter, which TicketSettings to fetch.
     */
    where: TicketSettingsWhereUniqueInput
  }

  /**
   * TicketSettings findFirst
   */
  export type TicketSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketSettings
     */
    select?: TicketSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketSettings
     */
    omit?: TicketSettingsOmit<ExtArgs> | null
    /**
     * Filter, which TicketSettings to fetch.
     */
    where?: TicketSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketSettings to fetch.
     */
    orderBy?: TicketSettingsOrderByWithRelationInput | TicketSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketSettings.
     */
    cursor?: TicketSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketSettings.
     */
    distinct?: TicketSettingsScalarFieldEnum | TicketSettingsScalarFieldEnum[]
  }

  /**
   * TicketSettings findFirstOrThrow
   */
  export type TicketSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketSettings
     */
    select?: TicketSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketSettings
     */
    omit?: TicketSettingsOmit<ExtArgs> | null
    /**
     * Filter, which TicketSettings to fetch.
     */
    where?: TicketSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketSettings to fetch.
     */
    orderBy?: TicketSettingsOrderByWithRelationInput | TicketSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketSettings.
     */
    cursor?: TicketSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketSettings.
     */
    distinct?: TicketSettingsScalarFieldEnum | TicketSettingsScalarFieldEnum[]
  }

  /**
   * TicketSettings findMany
   */
  export type TicketSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketSettings
     */
    select?: TicketSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketSettings
     */
    omit?: TicketSettingsOmit<ExtArgs> | null
    /**
     * Filter, which TicketSettings to fetch.
     */
    where?: TicketSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketSettings to fetch.
     */
    orderBy?: TicketSettingsOrderByWithRelationInput | TicketSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TicketSettings.
     */
    cursor?: TicketSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketSettings.
     */
    skip?: number
    distinct?: TicketSettingsScalarFieldEnum | TicketSettingsScalarFieldEnum[]
  }

  /**
   * TicketSettings create
   */
  export type TicketSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketSettings
     */
    select?: TicketSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketSettings
     */
    omit?: TicketSettingsOmit<ExtArgs> | null
    /**
     * The data needed to create a TicketSettings.
     */
    data: XOR<TicketSettingsCreateInput, TicketSettingsUncheckedCreateInput>
  }

  /**
   * TicketSettings createMany
   */
  export type TicketSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TicketSettings.
     */
    data: TicketSettingsCreateManyInput | TicketSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TicketSettings createManyAndReturn
   */
  export type TicketSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketSettings
     */
    select?: TicketSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TicketSettings
     */
    omit?: TicketSettingsOmit<ExtArgs> | null
    /**
     * The data used to create many TicketSettings.
     */
    data: TicketSettingsCreateManyInput | TicketSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TicketSettings update
   */
  export type TicketSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketSettings
     */
    select?: TicketSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketSettings
     */
    omit?: TicketSettingsOmit<ExtArgs> | null
    /**
     * The data needed to update a TicketSettings.
     */
    data: XOR<TicketSettingsUpdateInput, TicketSettingsUncheckedUpdateInput>
    /**
     * Choose, which TicketSettings to update.
     */
    where: TicketSettingsWhereUniqueInput
  }

  /**
   * TicketSettings updateMany
   */
  export type TicketSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TicketSettings.
     */
    data: XOR<TicketSettingsUpdateManyMutationInput, TicketSettingsUncheckedUpdateManyInput>
    /**
     * Filter which TicketSettings to update
     */
    where?: TicketSettingsWhereInput
    /**
     * Limit how many TicketSettings to update.
     */
    limit?: number
  }

  /**
   * TicketSettings updateManyAndReturn
   */
  export type TicketSettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketSettings
     */
    select?: TicketSettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TicketSettings
     */
    omit?: TicketSettingsOmit<ExtArgs> | null
    /**
     * The data used to update TicketSettings.
     */
    data: XOR<TicketSettingsUpdateManyMutationInput, TicketSettingsUncheckedUpdateManyInput>
    /**
     * Filter which TicketSettings to update
     */
    where?: TicketSettingsWhereInput
    /**
     * Limit how many TicketSettings to update.
     */
    limit?: number
  }

  /**
   * TicketSettings upsert
   */
  export type TicketSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketSettings
     */
    select?: TicketSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketSettings
     */
    omit?: TicketSettingsOmit<ExtArgs> | null
    /**
     * The filter to search for the TicketSettings to update in case it exists.
     */
    where: TicketSettingsWhereUniqueInput
    /**
     * In case the TicketSettings found by the `where` argument doesn't exist, create a new TicketSettings with this data.
     */
    create: XOR<TicketSettingsCreateInput, TicketSettingsUncheckedCreateInput>
    /**
     * In case the TicketSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketSettingsUpdateInput, TicketSettingsUncheckedUpdateInput>
  }

  /**
   * TicketSettings delete
   */
  export type TicketSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketSettings
     */
    select?: TicketSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketSettings
     */
    omit?: TicketSettingsOmit<ExtArgs> | null
    /**
     * Filter which TicketSettings to delete.
     */
    where: TicketSettingsWhereUniqueInput
  }

  /**
   * TicketSettings deleteMany
   */
  export type TicketSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketSettings to delete
     */
    where?: TicketSettingsWhereInput
    /**
     * Limit how many TicketSettings to delete.
     */
    limit?: number
  }

  /**
   * TicketSettings without action
   */
  export type TicketSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketSettings
     */
    select?: TicketSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketSettings
     */
    omit?: TicketSettingsOmit<ExtArgs> | null
  }


  /**
   * Model PlayerProfile
   */

  export type AggregatePlayerProfile = {
    _count: PlayerProfileCountAggregateOutputType | null
    _avg: PlayerProfileAvgAggregateOutputType | null
    _sum: PlayerProfileSumAggregateOutputType | null
    _min: PlayerProfileMinAggregateOutputType | null
    _max: PlayerProfileMaxAggregateOutputType | null
  }

  export type PlayerProfileAvgAggregateOutputType = {
    id: number | null
  }

  export type PlayerProfileSumAggregateOutputType = {
    id: number | null
  }

  export type PlayerProfileMinAggregateOutputType = {
    id: number | null
    discordUserId: string | null
    ign: string | null
    lastSeen: Date | null
    clanName: string | null
    createdAt: Date | null
  }

  export type PlayerProfileMaxAggregateOutputType = {
    id: number | null
    discordUserId: string | null
    ign: string | null
    lastSeen: Date | null
    clanName: string | null
    createdAt: Date | null
  }

  export type PlayerProfileCountAggregateOutputType = {
    id: number
    discordUserId: number
    ign: number
    lastSeen: number
    ranks: number
    clanName: number
    rankInfo: number
    friends: number
    createdAt: number
    _all: number
  }


  export type PlayerProfileAvgAggregateInputType = {
    id?: true
  }

  export type PlayerProfileSumAggregateInputType = {
    id?: true
  }

  export type PlayerProfileMinAggregateInputType = {
    id?: true
    discordUserId?: true
    ign?: true
    lastSeen?: true
    clanName?: true
    createdAt?: true
  }

  export type PlayerProfileMaxAggregateInputType = {
    id?: true
    discordUserId?: true
    ign?: true
    lastSeen?: true
    clanName?: true
    createdAt?: true
  }

  export type PlayerProfileCountAggregateInputType = {
    id?: true
    discordUserId?: true
    ign?: true
    lastSeen?: true
    ranks?: true
    clanName?: true
    rankInfo?: true
    friends?: true
    createdAt?: true
    _all?: true
  }

  export type PlayerProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerProfile to aggregate.
     */
    where?: PlayerProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerProfiles to fetch.
     */
    orderBy?: PlayerProfileOrderByWithRelationInput | PlayerProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlayerProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlayerProfiles
    **/
    _count?: true | PlayerProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlayerProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlayerProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlayerProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlayerProfileMaxAggregateInputType
  }

  export type GetPlayerProfileAggregateType<T extends PlayerProfileAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayerProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayerProfile[P]>
      : GetScalarType<T[P], AggregatePlayerProfile[P]>
  }




  export type PlayerProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerProfileWhereInput
    orderBy?: PlayerProfileOrderByWithAggregationInput | PlayerProfileOrderByWithAggregationInput[]
    by: PlayerProfileScalarFieldEnum[] | PlayerProfileScalarFieldEnum
    having?: PlayerProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlayerProfileCountAggregateInputType | true
    _avg?: PlayerProfileAvgAggregateInputType
    _sum?: PlayerProfileSumAggregateInputType
    _min?: PlayerProfileMinAggregateInputType
    _max?: PlayerProfileMaxAggregateInputType
  }

  export type PlayerProfileGroupByOutputType = {
    id: number
    discordUserId: string
    ign: string
    lastSeen: Date | null
    ranks: JsonValue | null
    clanName: string | null
    rankInfo: JsonValue | null
    friends: JsonValue | null
    createdAt: Date
    _count: PlayerProfileCountAggregateOutputType | null
    _avg: PlayerProfileAvgAggregateOutputType | null
    _sum: PlayerProfileSumAggregateOutputType | null
    _min: PlayerProfileMinAggregateOutputType | null
    _max: PlayerProfileMaxAggregateOutputType | null
  }

  type GetPlayerProfileGroupByPayload<T extends PlayerProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlayerProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlayerProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlayerProfileGroupByOutputType[P]>
            : GetScalarType<T[P], PlayerProfileGroupByOutputType[P]>
        }
      >
    >


  export type PlayerProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    discordUserId?: boolean
    ign?: boolean
    lastSeen?: boolean
    ranks?: boolean
    clanName?: boolean
    rankInfo?: boolean
    friends?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["playerProfile"]>

  export type PlayerProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    discordUserId?: boolean
    ign?: boolean
    lastSeen?: boolean
    ranks?: boolean
    clanName?: boolean
    rankInfo?: boolean
    friends?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["playerProfile"]>

  export type PlayerProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    discordUserId?: boolean
    ign?: boolean
    lastSeen?: boolean
    ranks?: boolean
    clanName?: boolean
    rankInfo?: boolean
    friends?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["playerProfile"]>

  export type PlayerProfileSelectScalar = {
    id?: boolean
    discordUserId?: boolean
    ign?: boolean
    lastSeen?: boolean
    ranks?: boolean
    clanName?: boolean
    rankInfo?: boolean
    friends?: boolean
    createdAt?: boolean
  }

  export type PlayerProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "discordUserId" | "ign" | "lastSeen" | "ranks" | "clanName" | "rankInfo" | "friends" | "createdAt", ExtArgs["result"]["playerProfile"]>

  export type $PlayerProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlayerProfile"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      discordUserId: string
      ign: string
      lastSeen: Date | null
      ranks: Prisma.JsonValue | null
      clanName: string | null
      rankInfo: Prisma.JsonValue | null
      friends: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["playerProfile"]>
    composites: {}
  }

  type PlayerProfileGetPayload<S extends boolean | null | undefined | PlayerProfileDefaultArgs> = $Result.GetResult<Prisma.$PlayerProfilePayload, S>

  type PlayerProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlayerProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlayerProfileCountAggregateInputType | true
    }

  export interface PlayerProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlayerProfile'], meta: { name: 'PlayerProfile' } }
    /**
     * Find zero or one PlayerProfile that matches the filter.
     * @param {PlayerProfileFindUniqueArgs} args - Arguments to find a PlayerProfile
     * @example
     * // Get one PlayerProfile
     * const playerProfile = await prisma.playerProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlayerProfileFindUniqueArgs>(args: SelectSubset<T, PlayerProfileFindUniqueArgs<ExtArgs>>): Prisma__PlayerProfileClient<$Result.GetResult<Prisma.$PlayerProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlayerProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlayerProfileFindUniqueOrThrowArgs} args - Arguments to find a PlayerProfile
     * @example
     * // Get one PlayerProfile
     * const playerProfile = await prisma.playerProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlayerProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, PlayerProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlayerProfileClient<$Result.GetResult<Prisma.$PlayerProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlayerProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerProfileFindFirstArgs} args - Arguments to find a PlayerProfile
     * @example
     * // Get one PlayerProfile
     * const playerProfile = await prisma.playerProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlayerProfileFindFirstArgs>(args?: SelectSubset<T, PlayerProfileFindFirstArgs<ExtArgs>>): Prisma__PlayerProfileClient<$Result.GetResult<Prisma.$PlayerProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlayerProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerProfileFindFirstOrThrowArgs} args - Arguments to find a PlayerProfile
     * @example
     * // Get one PlayerProfile
     * const playerProfile = await prisma.playerProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlayerProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, PlayerProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlayerProfileClient<$Result.GetResult<Prisma.$PlayerProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlayerProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlayerProfiles
     * const playerProfiles = await prisma.playerProfile.findMany()
     * 
     * // Get first 10 PlayerProfiles
     * const playerProfiles = await prisma.playerProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playerProfileWithIdOnly = await prisma.playerProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlayerProfileFindManyArgs>(args?: SelectSubset<T, PlayerProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlayerProfile.
     * @param {PlayerProfileCreateArgs} args - Arguments to create a PlayerProfile.
     * @example
     * // Create one PlayerProfile
     * const PlayerProfile = await prisma.playerProfile.create({
     *   data: {
     *     // ... data to create a PlayerProfile
     *   }
     * })
     * 
     */
    create<T extends PlayerProfileCreateArgs>(args: SelectSubset<T, PlayerProfileCreateArgs<ExtArgs>>): Prisma__PlayerProfileClient<$Result.GetResult<Prisma.$PlayerProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlayerProfiles.
     * @param {PlayerProfileCreateManyArgs} args - Arguments to create many PlayerProfiles.
     * @example
     * // Create many PlayerProfiles
     * const playerProfile = await prisma.playerProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlayerProfileCreateManyArgs>(args?: SelectSubset<T, PlayerProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlayerProfiles and returns the data saved in the database.
     * @param {PlayerProfileCreateManyAndReturnArgs} args - Arguments to create many PlayerProfiles.
     * @example
     * // Create many PlayerProfiles
     * const playerProfile = await prisma.playerProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlayerProfiles and only return the `id`
     * const playerProfileWithIdOnly = await prisma.playerProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlayerProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, PlayerProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlayerProfile.
     * @param {PlayerProfileDeleteArgs} args - Arguments to delete one PlayerProfile.
     * @example
     * // Delete one PlayerProfile
     * const PlayerProfile = await prisma.playerProfile.delete({
     *   where: {
     *     // ... filter to delete one PlayerProfile
     *   }
     * })
     * 
     */
    delete<T extends PlayerProfileDeleteArgs>(args: SelectSubset<T, PlayerProfileDeleteArgs<ExtArgs>>): Prisma__PlayerProfileClient<$Result.GetResult<Prisma.$PlayerProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlayerProfile.
     * @param {PlayerProfileUpdateArgs} args - Arguments to update one PlayerProfile.
     * @example
     * // Update one PlayerProfile
     * const playerProfile = await prisma.playerProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlayerProfileUpdateArgs>(args: SelectSubset<T, PlayerProfileUpdateArgs<ExtArgs>>): Prisma__PlayerProfileClient<$Result.GetResult<Prisma.$PlayerProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlayerProfiles.
     * @param {PlayerProfileDeleteManyArgs} args - Arguments to filter PlayerProfiles to delete.
     * @example
     * // Delete a few PlayerProfiles
     * const { count } = await prisma.playerProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlayerProfileDeleteManyArgs>(args?: SelectSubset<T, PlayerProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlayerProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlayerProfiles
     * const playerProfile = await prisma.playerProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlayerProfileUpdateManyArgs>(args: SelectSubset<T, PlayerProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlayerProfiles and returns the data updated in the database.
     * @param {PlayerProfileUpdateManyAndReturnArgs} args - Arguments to update many PlayerProfiles.
     * @example
     * // Update many PlayerProfiles
     * const playerProfile = await prisma.playerProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlayerProfiles and only return the `id`
     * const playerProfileWithIdOnly = await prisma.playerProfile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlayerProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, PlayerProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlayerProfile.
     * @param {PlayerProfileUpsertArgs} args - Arguments to update or create a PlayerProfile.
     * @example
     * // Update or create a PlayerProfile
     * const playerProfile = await prisma.playerProfile.upsert({
     *   create: {
     *     // ... data to create a PlayerProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlayerProfile we want to update
     *   }
     * })
     */
    upsert<T extends PlayerProfileUpsertArgs>(args: SelectSubset<T, PlayerProfileUpsertArgs<ExtArgs>>): Prisma__PlayerProfileClient<$Result.GetResult<Prisma.$PlayerProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlayerProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerProfileCountArgs} args - Arguments to filter PlayerProfiles to count.
     * @example
     * // Count the number of PlayerProfiles
     * const count = await prisma.playerProfile.count({
     *   where: {
     *     // ... the filter for the PlayerProfiles we want to count
     *   }
     * })
    **/
    count<T extends PlayerProfileCountArgs>(
      args?: Subset<T, PlayerProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlayerProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlayerProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlayerProfileAggregateArgs>(args: Subset<T, PlayerProfileAggregateArgs>): Prisma.PrismaPromise<GetPlayerProfileAggregateType<T>>

    /**
     * Group by PlayerProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlayerProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlayerProfileGroupByArgs['orderBy'] }
        : { orderBy?: PlayerProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlayerProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayerProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlayerProfile model
   */
  readonly fields: PlayerProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlayerProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlayerProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlayerProfile model
   */ 
  interface PlayerProfileFieldRefs {
    readonly id: FieldRef<"PlayerProfile", 'Int'>
    readonly discordUserId: FieldRef<"PlayerProfile", 'String'>
    readonly ign: FieldRef<"PlayerProfile", 'String'>
    readonly lastSeen: FieldRef<"PlayerProfile", 'DateTime'>
    readonly ranks: FieldRef<"PlayerProfile", 'Json'>
    readonly clanName: FieldRef<"PlayerProfile", 'String'>
    readonly rankInfo: FieldRef<"PlayerProfile", 'Json'>
    readonly friends: FieldRef<"PlayerProfile", 'Json'>
    readonly createdAt: FieldRef<"PlayerProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlayerProfile findUnique
   */
  export type PlayerProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerProfile
     */
    select?: PlayerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerProfile
     */
    omit?: PlayerProfileOmit<ExtArgs> | null
    /**
     * Filter, which PlayerProfile to fetch.
     */
    where: PlayerProfileWhereUniqueInput
  }

  /**
   * PlayerProfile findUniqueOrThrow
   */
  export type PlayerProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerProfile
     */
    select?: PlayerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerProfile
     */
    omit?: PlayerProfileOmit<ExtArgs> | null
    /**
     * Filter, which PlayerProfile to fetch.
     */
    where: PlayerProfileWhereUniqueInput
  }

  /**
   * PlayerProfile findFirst
   */
  export type PlayerProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerProfile
     */
    select?: PlayerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerProfile
     */
    omit?: PlayerProfileOmit<ExtArgs> | null
    /**
     * Filter, which PlayerProfile to fetch.
     */
    where?: PlayerProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerProfiles to fetch.
     */
    orderBy?: PlayerProfileOrderByWithRelationInput | PlayerProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerProfiles.
     */
    cursor?: PlayerProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerProfiles.
     */
    distinct?: PlayerProfileScalarFieldEnum | PlayerProfileScalarFieldEnum[]
  }

  /**
   * PlayerProfile findFirstOrThrow
   */
  export type PlayerProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerProfile
     */
    select?: PlayerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerProfile
     */
    omit?: PlayerProfileOmit<ExtArgs> | null
    /**
     * Filter, which PlayerProfile to fetch.
     */
    where?: PlayerProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerProfiles to fetch.
     */
    orderBy?: PlayerProfileOrderByWithRelationInput | PlayerProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerProfiles.
     */
    cursor?: PlayerProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerProfiles.
     */
    distinct?: PlayerProfileScalarFieldEnum | PlayerProfileScalarFieldEnum[]
  }

  /**
   * PlayerProfile findMany
   */
  export type PlayerProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerProfile
     */
    select?: PlayerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerProfile
     */
    omit?: PlayerProfileOmit<ExtArgs> | null
    /**
     * Filter, which PlayerProfiles to fetch.
     */
    where?: PlayerProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerProfiles to fetch.
     */
    orderBy?: PlayerProfileOrderByWithRelationInput | PlayerProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlayerProfiles.
     */
    cursor?: PlayerProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerProfiles.
     */
    skip?: number
    distinct?: PlayerProfileScalarFieldEnum | PlayerProfileScalarFieldEnum[]
  }

  /**
   * PlayerProfile create
   */
  export type PlayerProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerProfile
     */
    select?: PlayerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerProfile
     */
    omit?: PlayerProfileOmit<ExtArgs> | null
    /**
     * The data needed to create a PlayerProfile.
     */
    data: XOR<PlayerProfileCreateInput, PlayerProfileUncheckedCreateInput>
  }

  /**
   * PlayerProfile createMany
   */
  export type PlayerProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlayerProfiles.
     */
    data: PlayerProfileCreateManyInput | PlayerProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlayerProfile createManyAndReturn
   */
  export type PlayerProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerProfile
     */
    select?: PlayerProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerProfile
     */
    omit?: PlayerProfileOmit<ExtArgs> | null
    /**
     * The data used to create many PlayerProfiles.
     */
    data: PlayerProfileCreateManyInput | PlayerProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlayerProfile update
   */
  export type PlayerProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerProfile
     */
    select?: PlayerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerProfile
     */
    omit?: PlayerProfileOmit<ExtArgs> | null
    /**
     * The data needed to update a PlayerProfile.
     */
    data: XOR<PlayerProfileUpdateInput, PlayerProfileUncheckedUpdateInput>
    /**
     * Choose, which PlayerProfile to update.
     */
    where: PlayerProfileWhereUniqueInput
  }

  /**
   * PlayerProfile updateMany
   */
  export type PlayerProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlayerProfiles.
     */
    data: XOR<PlayerProfileUpdateManyMutationInput, PlayerProfileUncheckedUpdateManyInput>
    /**
     * Filter which PlayerProfiles to update
     */
    where?: PlayerProfileWhereInput
    /**
     * Limit how many PlayerProfiles to update.
     */
    limit?: number
  }

  /**
   * PlayerProfile updateManyAndReturn
   */
  export type PlayerProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerProfile
     */
    select?: PlayerProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerProfile
     */
    omit?: PlayerProfileOmit<ExtArgs> | null
    /**
     * The data used to update PlayerProfiles.
     */
    data: XOR<PlayerProfileUpdateManyMutationInput, PlayerProfileUncheckedUpdateManyInput>
    /**
     * Filter which PlayerProfiles to update
     */
    where?: PlayerProfileWhereInput
    /**
     * Limit how many PlayerProfiles to update.
     */
    limit?: number
  }

  /**
   * PlayerProfile upsert
   */
  export type PlayerProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerProfile
     */
    select?: PlayerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerProfile
     */
    omit?: PlayerProfileOmit<ExtArgs> | null
    /**
     * The filter to search for the PlayerProfile to update in case it exists.
     */
    where: PlayerProfileWhereUniqueInput
    /**
     * In case the PlayerProfile found by the `where` argument doesn't exist, create a new PlayerProfile with this data.
     */
    create: XOR<PlayerProfileCreateInput, PlayerProfileUncheckedCreateInput>
    /**
     * In case the PlayerProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlayerProfileUpdateInput, PlayerProfileUncheckedUpdateInput>
  }

  /**
   * PlayerProfile delete
   */
  export type PlayerProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerProfile
     */
    select?: PlayerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerProfile
     */
    omit?: PlayerProfileOmit<ExtArgs> | null
    /**
     * Filter which PlayerProfile to delete.
     */
    where: PlayerProfileWhereUniqueInput
  }

  /**
   * PlayerProfile deleteMany
   */
  export type PlayerProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerProfiles to delete
     */
    where?: PlayerProfileWhereInput
    /**
     * Limit how many PlayerProfiles to delete.
     */
    limit?: number
  }

  /**
   * PlayerProfile without action
   */
  export type PlayerProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerProfile
     */
    select?: PlayerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerProfile
     */
    omit?: PlayerProfileOmit<ExtArgs> | null
  }


  /**
   * Model TicketConfig
   */

  export type AggregateTicketConfig = {
    _count: TicketConfigCountAggregateOutputType | null
    _avg: TicketConfigAvgAggregateOutputType | null
    _sum: TicketConfigSumAggregateOutputType | null
    _min: TicketConfigMinAggregateOutputType | null
    _max: TicketConfigMaxAggregateOutputType | null
  }

  export type TicketConfigAvgAggregateOutputType = {
    id: number | null
  }

  export type TicketConfigSumAggregateOutputType = {
    id: number | null
  }

  export type TicketConfigMinAggregateOutputType = {
    id: number | null
    ticketType: string | null
    allowCustomInstructions: boolean | null
    useCustomInstructions: boolean | null
    instructions: string | null
    previewTitle: string | null
  }

  export type TicketConfigMaxAggregateOutputType = {
    id: number | null
    ticketType: string | null
    allowCustomInstructions: boolean | null
    useCustomInstructions: boolean | null
    instructions: string | null
    previewTitle: string | null
  }

  export type TicketConfigCountAggregateOutputType = {
    id: number
    ticketType: number
    permissions: number
    allowCustomInstructions: number
    useCustomInstructions: number
    instructions: number
    previewTitle: number
    _all: number
  }


  export type TicketConfigAvgAggregateInputType = {
    id?: true
  }

  export type TicketConfigSumAggregateInputType = {
    id?: true
  }

  export type TicketConfigMinAggregateInputType = {
    id?: true
    ticketType?: true
    allowCustomInstructions?: true
    useCustomInstructions?: true
    instructions?: true
    previewTitle?: true
  }

  export type TicketConfigMaxAggregateInputType = {
    id?: true
    ticketType?: true
    allowCustomInstructions?: true
    useCustomInstructions?: true
    instructions?: true
    previewTitle?: true
  }

  export type TicketConfigCountAggregateInputType = {
    id?: true
    ticketType?: true
    permissions?: true
    allowCustomInstructions?: true
    useCustomInstructions?: true
    instructions?: true
    previewTitle?: true
    _all?: true
  }

  export type TicketConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketConfig to aggregate.
     */
    where?: TicketConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketConfigs to fetch.
     */
    orderBy?: TicketConfigOrderByWithRelationInput | TicketConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TicketConfigs
    **/
    _count?: true | TicketConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TicketConfigAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TicketConfigSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketConfigMaxAggregateInputType
  }

  export type GetTicketConfigAggregateType<T extends TicketConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateTicketConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicketConfig[P]>
      : GetScalarType<T[P], AggregateTicketConfig[P]>
  }




  export type TicketConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketConfigWhereInput
    orderBy?: TicketConfigOrderByWithAggregationInput | TicketConfigOrderByWithAggregationInput[]
    by: TicketConfigScalarFieldEnum[] | TicketConfigScalarFieldEnum
    having?: TicketConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketConfigCountAggregateInputType | true
    _avg?: TicketConfigAvgAggregateInputType
    _sum?: TicketConfigSumAggregateInputType
    _min?: TicketConfigMinAggregateInputType
    _max?: TicketConfigMaxAggregateInputType
  }

  export type TicketConfigGroupByOutputType = {
    id: number
    ticketType: string
    permissions: JsonValue | null
    allowCustomInstructions: boolean
    useCustomInstructions: boolean
    instructions: string | null
    previewTitle: string | null
    _count: TicketConfigCountAggregateOutputType | null
    _avg: TicketConfigAvgAggregateOutputType | null
    _sum: TicketConfigSumAggregateOutputType | null
    _min: TicketConfigMinAggregateOutputType | null
    _max: TicketConfigMaxAggregateOutputType | null
  }

  type GetTicketConfigGroupByPayload<T extends TicketConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketConfigGroupByOutputType[P]>
            : GetScalarType<T[P], TicketConfigGroupByOutputType[P]>
        }
      >
    >


  export type TicketConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketType?: boolean
    permissions?: boolean
    allowCustomInstructions?: boolean
    useCustomInstructions?: boolean
    instructions?: boolean
    previewTitle?: boolean
  }, ExtArgs["result"]["ticketConfig"]>

  export type TicketConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketType?: boolean
    permissions?: boolean
    allowCustomInstructions?: boolean
    useCustomInstructions?: boolean
    instructions?: boolean
    previewTitle?: boolean
  }, ExtArgs["result"]["ticketConfig"]>

  export type TicketConfigSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketType?: boolean
    permissions?: boolean
    allowCustomInstructions?: boolean
    useCustomInstructions?: boolean
    instructions?: boolean
    previewTitle?: boolean
  }, ExtArgs["result"]["ticketConfig"]>

  export type TicketConfigSelectScalar = {
    id?: boolean
    ticketType?: boolean
    permissions?: boolean
    allowCustomInstructions?: boolean
    useCustomInstructions?: boolean
    instructions?: boolean
    previewTitle?: boolean
  }

  export type TicketConfigOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ticketType" | "permissions" | "allowCustomInstructions" | "useCustomInstructions" | "instructions" | "previewTitle", ExtArgs["result"]["ticketConfig"]>

  export type $TicketConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TicketConfig"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      ticketType: string
      permissions: Prisma.JsonValue | null
      allowCustomInstructions: boolean
      useCustomInstructions: boolean
      instructions: string | null
      previewTitle: string | null
    }, ExtArgs["result"]["ticketConfig"]>
    composites: {}
  }

  type TicketConfigGetPayload<S extends boolean | null | undefined | TicketConfigDefaultArgs> = $Result.GetResult<Prisma.$TicketConfigPayload, S>

  type TicketConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TicketConfigFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TicketConfigCountAggregateInputType | true
    }

  export interface TicketConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TicketConfig'], meta: { name: 'TicketConfig' } }
    /**
     * Find zero or one TicketConfig that matches the filter.
     * @param {TicketConfigFindUniqueArgs} args - Arguments to find a TicketConfig
     * @example
     * // Get one TicketConfig
     * const ticketConfig = await prisma.ticketConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketConfigFindUniqueArgs>(args: SelectSubset<T, TicketConfigFindUniqueArgs<ExtArgs>>): Prisma__TicketConfigClient<$Result.GetResult<Prisma.$TicketConfigPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TicketConfig that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TicketConfigFindUniqueOrThrowArgs} args - Arguments to find a TicketConfig
     * @example
     * // Get one TicketConfig
     * const ticketConfig = await prisma.ticketConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketConfigClient<$Result.GetResult<Prisma.$TicketConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TicketConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketConfigFindFirstArgs} args - Arguments to find a TicketConfig
     * @example
     * // Get one TicketConfig
     * const ticketConfig = await prisma.ticketConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketConfigFindFirstArgs>(args?: SelectSubset<T, TicketConfigFindFirstArgs<ExtArgs>>): Prisma__TicketConfigClient<$Result.GetResult<Prisma.$TicketConfigPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TicketConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketConfigFindFirstOrThrowArgs} args - Arguments to find a TicketConfig
     * @example
     * // Get one TicketConfig
     * const ticketConfig = await prisma.ticketConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketConfigClient<$Result.GetResult<Prisma.$TicketConfigPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TicketConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TicketConfigs
     * const ticketConfigs = await prisma.ticketConfig.findMany()
     * 
     * // Get first 10 TicketConfigs
     * const ticketConfigs = await prisma.ticketConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketConfigWithIdOnly = await prisma.ticketConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketConfigFindManyArgs>(args?: SelectSubset<T, TicketConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TicketConfig.
     * @param {TicketConfigCreateArgs} args - Arguments to create a TicketConfig.
     * @example
     * // Create one TicketConfig
     * const TicketConfig = await prisma.ticketConfig.create({
     *   data: {
     *     // ... data to create a TicketConfig
     *   }
     * })
     * 
     */
    create<T extends TicketConfigCreateArgs>(args: SelectSubset<T, TicketConfigCreateArgs<ExtArgs>>): Prisma__TicketConfigClient<$Result.GetResult<Prisma.$TicketConfigPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TicketConfigs.
     * @param {TicketConfigCreateManyArgs} args - Arguments to create many TicketConfigs.
     * @example
     * // Create many TicketConfigs
     * const ticketConfig = await prisma.ticketConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketConfigCreateManyArgs>(args?: SelectSubset<T, TicketConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TicketConfigs and returns the data saved in the database.
     * @param {TicketConfigCreateManyAndReturnArgs} args - Arguments to create many TicketConfigs.
     * @example
     * // Create many TicketConfigs
     * const ticketConfig = await prisma.ticketConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TicketConfigs and only return the `id`
     * const ticketConfigWithIdOnly = await prisma.ticketConfig.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TicketConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, TicketConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketConfigPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TicketConfig.
     * @param {TicketConfigDeleteArgs} args - Arguments to delete one TicketConfig.
     * @example
     * // Delete one TicketConfig
     * const TicketConfig = await prisma.ticketConfig.delete({
     *   where: {
     *     // ... filter to delete one TicketConfig
     *   }
     * })
     * 
     */
    delete<T extends TicketConfigDeleteArgs>(args: SelectSubset<T, TicketConfigDeleteArgs<ExtArgs>>): Prisma__TicketConfigClient<$Result.GetResult<Prisma.$TicketConfigPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TicketConfig.
     * @param {TicketConfigUpdateArgs} args - Arguments to update one TicketConfig.
     * @example
     * // Update one TicketConfig
     * const ticketConfig = await prisma.ticketConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketConfigUpdateArgs>(args: SelectSubset<T, TicketConfigUpdateArgs<ExtArgs>>): Prisma__TicketConfigClient<$Result.GetResult<Prisma.$TicketConfigPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TicketConfigs.
     * @param {TicketConfigDeleteManyArgs} args - Arguments to filter TicketConfigs to delete.
     * @example
     * // Delete a few TicketConfigs
     * const { count } = await prisma.ticketConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketConfigDeleteManyArgs>(args?: SelectSubset<T, TicketConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TicketConfigs
     * const ticketConfig = await prisma.ticketConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketConfigUpdateManyArgs>(args: SelectSubset<T, TicketConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketConfigs and returns the data updated in the database.
     * @param {TicketConfigUpdateManyAndReturnArgs} args - Arguments to update many TicketConfigs.
     * @example
     * // Update many TicketConfigs
     * const ticketConfig = await prisma.ticketConfig.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TicketConfigs and only return the `id`
     * const ticketConfigWithIdOnly = await prisma.ticketConfig.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TicketConfigUpdateManyAndReturnArgs>(args: SelectSubset<T, TicketConfigUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketConfigPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TicketConfig.
     * @param {TicketConfigUpsertArgs} args - Arguments to update or create a TicketConfig.
     * @example
     * // Update or create a TicketConfig
     * const ticketConfig = await prisma.ticketConfig.upsert({
     *   create: {
     *     // ... data to create a TicketConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TicketConfig we want to update
     *   }
     * })
     */
    upsert<T extends TicketConfigUpsertArgs>(args: SelectSubset<T, TicketConfigUpsertArgs<ExtArgs>>): Prisma__TicketConfigClient<$Result.GetResult<Prisma.$TicketConfigPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TicketConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketConfigCountArgs} args - Arguments to filter TicketConfigs to count.
     * @example
     * // Count the number of TicketConfigs
     * const count = await prisma.ticketConfig.count({
     *   where: {
     *     // ... the filter for the TicketConfigs we want to count
     *   }
     * })
    **/
    count<T extends TicketConfigCountArgs>(
      args?: Subset<T, TicketConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TicketConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketConfigAggregateArgs>(args: Subset<T, TicketConfigAggregateArgs>): Prisma.PrismaPromise<GetTicketConfigAggregateType<T>>

    /**
     * Group by TicketConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketConfigGroupByArgs['orderBy'] }
        : { orderBy?: TicketConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TicketConfig model
   */
  readonly fields: TicketConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TicketConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TicketConfig model
   */ 
  interface TicketConfigFieldRefs {
    readonly id: FieldRef<"TicketConfig", 'Int'>
    readonly ticketType: FieldRef<"TicketConfig", 'String'>
    readonly permissions: FieldRef<"TicketConfig", 'Json'>
    readonly allowCustomInstructions: FieldRef<"TicketConfig", 'Boolean'>
    readonly useCustomInstructions: FieldRef<"TicketConfig", 'Boolean'>
    readonly instructions: FieldRef<"TicketConfig", 'String'>
    readonly previewTitle: FieldRef<"TicketConfig", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TicketConfig findUnique
   */
  export type TicketConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketConfig
     */
    select?: TicketConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketConfig
     */
    omit?: TicketConfigOmit<ExtArgs> | null
    /**
     * Filter, which TicketConfig to fetch.
     */
    where: TicketConfigWhereUniqueInput
  }

  /**
   * TicketConfig findUniqueOrThrow
   */
  export type TicketConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketConfig
     */
    select?: TicketConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketConfig
     */
    omit?: TicketConfigOmit<ExtArgs> | null
    /**
     * Filter, which TicketConfig to fetch.
     */
    where: TicketConfigWhereUniqueInput
  }

  /**
   * TicketConfig findFirst
   */
  export type TicketConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketConfig
     */
    select?: TicketConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketConfig
     */
    omit?: TicketConfigOmit<ExtArgs> | null
    /**
     * Filter, which TicketConfig to fetch.
     */
    where?: TicketConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketConfigs to fetch.
     */
    orderBy?: TicketConfigOrderByWithRelationInput | TicketConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketConfigs.
     */
    cursor?: TicketConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketConfigs.
     */
    distinct?: TicketConfigScalarFieldEnum | TicketConfigScalarFieldEnum[]
  }

  /**
   * TicketConfig findFirstOrThrow
   */
  export type TicketConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketConfig
     */
    select?: TicketConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketConfig
     */
    omit?: TicketConfigOmit<ExtArgs> | null
    /**
     * Filter, which TicketConfig to fetch.
     */
    where?: TicketConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketConfigs to fetch.
     */
    orderBy?: TicketConfigOrderByWithRelationInput | TicketConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketConfigs.
     */
    cursor?: TicketConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketConfigs.
     */
    distinct?: TicketConfigScalarFieldEnum | TicketConfigScalarFieldEnum[]
  }

  /**
   * TicketConfig findMany
   */
  export type TicketConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketConfig
     */
    select?: TicketConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketConfig
     */
    omit?: TicketConfigOmit<ExtArgs> | null
    /**
     * Filter, which TicketConfigs to fetch.
     */
    where?: TicketConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketConfigs to fetch.
     */
    orderBy?: TicketConfigOrderByWithRelationInput | TicketConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TicketConfigs.
     */
    cursor?: TicketConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketConfigs.
     */
    skip?: number
    distinct?: TicketConfigScalarFieldEnum | TicketConfigScalarFieldEnum[]
  }

  /**
   * TicketConfig create
   */
  export type TicketConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketConfig
     */
    select?: TicketConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketConfig
     */
    omit?: TicketConfigOmit<ExtArgs> | null
    /**
     * The data needed to create a TicketConfig.
     */
    data: XOR<TicketConfigCreateInput, TicketConfigUncheckedCreateInput>
  }

  /**
   * TicketConfig createMany
   */
  export type TicketConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TicketConfigs.
     */
    data: TicketConfigCreateManyInput | TicketConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TicketConfig createManyAndReturn
   */
  export type TicketConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketConfig
     */
    select?: TicketConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TicketConfig
     */
    omit?: TicketConfigOmit<ExtArgs> | null
    /**
     * The data used to create many TicketConfigs.
     */
    data: TicketConfigCreateManyInput | TicketConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TicketConfig update
   */
  export type TicketConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketConfig
     */
    select?: TicketConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketConfig
     */
    omit?: TicketConfigOmit<ExtArgs> | null
    /**
     * The data needed to update a TicketConfig.
     */
    data: XOR<TicketConfigUpdateInput, TicketConfigUncheckedUpdateInput>
    /**
     * Choose, which TicketConfig to update.
     */
    where: TicketConfigWhereUniqueInput
  }

  /**
   * TicketConfig updateMany
   */
  export type TicketConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TicketConfigs.
     */
    data: XOR<TicketConfigUpdateManyMutationInput, TicketConfigUncheckedUpdateManyInput>
    /**
     * Filter which TicketConfigs to update
     */
    where?: TicketConfigWhereInput
    /**
     * Limit how many TicketConfigs to update.
     */
    limit?: number
  }

  /**
   * TicketConfig updateManyAndReturn
   */
  export type TicketConfigUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketConfig
     */
    select?: TicketConfigSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TicketConfig
     */
    omit?: TicketConfigOmit<ExtArgs> | null
    /**
     * The data used to update TicketConfigs.
     */
    data: XOR<TicketConfigUpdateManyMutationInput, TicketConfigUncheckedUpdateManyInput>
    /**
     * Filter which TicketConfigs to update
     */
    where?: TicketConfigWhereInput
    /**
     * Limit how many TicketConfigs to update.
     */
    limit?: number
  }

  /**
   * TicketConfig upsert
   */
  export type TicketConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketConfig
     */
    select?: TicketConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketConfig
     */
    omit?: TicketConfigOmit<ExtArgs> | null
    /**
     * The filter to search for the TicketConfig to update in case it exists.
     */
    where: TicketConfigWhereUniqueInput
    /**
     * In case the TicketConfig found by the `where` argument doesn't exist, create a new TicketConfig with this data.
     */
    create: XOR<TicketConfigCreateInput, TicketConfigUncheckedCreateInput>
    /**
     * In case the TicketConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketConfigUpdateInput, TicketConfigUncheckedUpdateInput>
  }

  /**
   * TicketConfig delete
   */
  export type TicketConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketConfig
     */
    select?: TicketConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketConfig
     */
    omit?: TicketConfigOmit<ExtArgs> | null
    /**
     * Filter which TicketConfig to delete.
     */
    where: TicketConfigWhereUniqueInput
  }

  /**
   * TicketConfig deleteMany
   */
  export type TicketConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketConfigs to delete
     */
    where?: TicketConfigWhereInput
    /**
     * Limit how many TicketConfigs to delete.
     */
    limit?: number
  }

  /**
   * TicketConfig without action
   */
  export type TicketConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketConfig
     */
    select?: TicketConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketConfig
     */
    omit?: TicketConfigOmit<ExtArgs> | null
  }


  /**
   * Model TicketBlacklist
   */

  export type AggregateTicketBlacklist = {
    _count: TicketBlacklistCountAggregateOutputType | null
    _avg: TicketBlacklistAvgAggregateOutputType | null
    _sum: TicketBlacklistSumAggregateOutputType | null
    _min: TicketBlacklistMinAggregateOutputType | null
    _max: TicketBlacklistMaxAggregateOutputType | null
  }

  export type TicketBlacklistAvgAggregateOutputType = {
    id: number | null
  }

  export type TicketBlacklistSumAggregateOutputType = {
    id: number | null
  }

  export type TicketBlacklistMinAggregateOutputType = {
    id: number | null
    userId: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type TicketBlacklistMaxAggregateOutputType = {
    id: number | null
    userId: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type TicketBlacklistCountAggregateOutputType = {
    id: number
    userId: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type TicketBlacklistAvgAggregateInputType = {
    id?: true
  }

  export type TicketBlacklistSumAggregateInputType = {
    id?: true
  }

  export type TicketBlacklistMinAggregateInputType = {
    id?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
  }

  export type TicketBlacklistMaxAggregateInputType = {
    id?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
  }

  export type TicketBlacklistCountAggregateInputType = {
    id?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type TicketBlacklistAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketBlacklist to aggregate.
     */
    where?: TicketBlacklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketBlacklists to fetch.
     */
    orderBy?: TicketBlacklistOrderByWithRelationInput | TicketBlacklistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketBlacklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketBlacklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketBlacklists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TicketBlacklists
    **/
    _count?: true | TicketBlacklistCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TicketBlacklistAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TicketBlacklistSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketBlacklistMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketBlacklistMaxAggregateInputType
  }

  export type GetTicketBlacklistAggregateType<T extends TicketBlacklistAggregateArgs> = {
        [P in keyof T & keyof AggregateTicketBlacklist]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicketBlacklist[P]>
      : GetScalarType<T[P], AggregateTicketBlacklist[P]>
  }




  export type TicketBlacklistGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketBlacklistWhereInput
    orderBy?: TicketBlacklistOrderByWithAggregationInput | TicketBlacklistOrderByWithAggregationInput[]
    by: TicketBlacklistScalarFieldEnum[] | TicketBlacklistScalarFieldEnum
    having?: TicketBlacklistScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketBlacklistCountAggregateInputType | true
    _avg?: TicketBlacklistAvgAggregateInputType
    _sum?: TicketBlacklistSumAggregateInputType
    _min?: TicketBlacklistMinAggregateInputType
    _max?: TicketBlacklistMaxAggregateInputType
  }

  export type TicketBlacklistGroupByOutputType = {
    id: number
    userId: string
    expiresAt: Date | null
    createdAt: Date
    _count: TicketBlacklistCountAggregateOutputType | null
    _avg: TicketBlacklistAvgAggregateOutputType | null
    _sum: TicketBlacklistSumAggregateOutputType | null
    _min: TicketBlacklistMinAggregateOutputType | null
    _max: TicketBlacklistMaxAggregateOutputType | null
  }

  type GetTicketBlacklistGroupByPayload<T extends TicketBlacklistGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketBlacklistGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketBlacklistGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketBlacklistGroupByOutputType[P]>
            : GetScalarType<T[P], TicketBlacklistGroupByOutputType[P]>
        }
      >
    >


  export type TicketBlacklistSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["ticketBlacklist"]>

  export type TicketBlacklistSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["ticketBlacklist"]>

  export type TicketBlacklistSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["ticketBlacklist"]>

  export type TicketBlacklistSelectScalar = {
    id?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type TicketBlacklistOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "expiresAt" | "createdAt", ExtArgs["result"]["ticketBlacklist"]>

  export type $TicketBlacklistPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TicketBlacklist"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: string
      expiresAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["ticketBlacklist"]>
    composites: {}
  }

  type TicketBlacklistGetPayload<S extends boolean | null | undefined | TicketBlacklistDefaultArgs> = $Result.GetResult<Prisma.$TicketBlacklistPayload, S>

  type TicketBlacklistCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TicketBlacklistFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TicketBlacklistCountAggregateInputType | true
    }

  export interface TicketBlacklistDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TicketBlacklist'], meta: { name: 'TicketBlacklist' } }
    /**
     * Find zero or one TicketBlacklist that matches the filter.
     * @param {TicketBlacklistFindUniqueArgs} args - Arguments to find a TicketBlacklist
     * @example
     * // Get one TicketBlacklist
     * const ticketBlacklist = await prisma.ticketBlacklist.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketBlacklistFindUniqueArgs>(args: SelectSubset<T, TicketBlacklistFindUniqueArgs<ExtArgs>>): Prisma__TicketBlacklistClient<$Result.GetResult<Prisma.$TicketBlacklistPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TicketBlacklist that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TicketBlacklistFindUniqueOrThrowArgs} args - Arguments to find a TicketBlacklist
     * @example
     * // Get one TicketBlacklist
     * const ticketBlacklist = await prisma.ticketBlacklist.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketBlacklistFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketBlacklistFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketBlacklistClient<$Result.GetResult<Prisma.$TicketBlacklistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TicketBlacklist that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketBlacklistFindFirstArgs} args - Arguments to find a TicketBlacklist
     * @example
     * // Get one TicketBlacklist
     * const ticketBlacklist = await prisma.ticketBlacklist.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketBlacklistFindFirstArgs>(args?: SelectSubset<T, TicketBlacklistFindFirstArgs<ExtArgs>>): Prisma__TicketBlacklistClient<$Result.GetResult<Prisma.$TicketBlacklistPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TicketBlacklist that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketBlacklistFindFirstOrThrowArgs} args - Arguments to find a TicketBlacklist
     * @example
     * // Get one TicketBlacklist
     * const ticketBlacklist = await prisma.ticketBlacklist.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketBlacklistFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketBlacklistFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketBlacklistClient<$Result.GetResult<Prisma.$TicketBlacklistPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TicketBlacklists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketBlacklistFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TicketBlacklists
     * const ticketBlacklists = await prisma.ticketBlacklist.findMany()
     * 
     * // Get first 10 TicketBlacklists
     * const ticketBlacklists = await prisma.ticketBlacklist.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketBlacklistWithIdOnly = await prisma.ticketBlacklist.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketBlacklistFindManyArgs>(args?: SelectSubset<T, TicketBlacklistFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketBlacklistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TicketBlacklist.
     * @param {TicketBlacklistCreateArgs} args - Arguments to create a TicketBlacklist.
     * @example
     * // Create one TicketBlacklist
     * const TicketBlacklist = await prisma.ticketBlacklist.create({
     *   data: {
     *     // ... data to create a TicketBlacklist
     *   }
     * })
     * 
     */
    create<T extends TicketBlacklistCreateArgs>(args: SelectSubset<T, TicketBlacklistCreateArgs<ExtArgs>>): Prisma__TicketBlacklistClient<$Result.GetResult<Prisma.$TicketBlacklistPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TicketBlacklists.
     * @param {TicketBlacklistCreateManyArgs} args - Arguments to create many TicketBlacklists.
     * @example
     * // Create many TicketBlacklists
     * const ticketBlacklist = await prisma.ticketBlacklist.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketBlacklistCreateManyArgs>(args?: SelectSubset<T, TicketBlacklistCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TicketBlacklists and returns the data saved in the database.
     * @param {TicketBlacklistCreateManyAndReturnArgs} args - Arguments to create many TicketBlacklists.
     * @example
     * // Create many TicketBlacklists
     * const ticketBlacklist = await prisma.ticketBlacklist.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TicketBlacklists and only return the `id`
     * const ticketBlacklistWithIdOnly = await prisma.ticketBlacklist.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TicketBlacklistCreateManyAndReturnArgs>(args?: SelectSubset<T, TicketBlacklistCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketBlacklistPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TicketBlacklist.
     * @param {TicketBlacklistDeleteArgs} args - Arguments to delete one TicketBlacklist.
     * @example
     * // Delete one TicketBlacklist
     * const TicketBlacklist = await prisma.ticketBlacklist.delete({
     *   where: {
     *     // ... filter to delete one TicketBlacklist
     *   }
     * })
     * 
     */
    delete<T extends TicketBlacklistDeleteArgs>(args: SelectSubset<T, TicketBlacklistDeleteArgs<ExtArgs>>): Prisma__TicketBlacklistClient<$Result.GetResult<Prisma.$TicketBlacklistPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TicketBlacklist.
     * @param {TicketBlacklistUpdateArgs} args - Arguments to update one TicketBlacklist.
     * @example
     * // Update one TicketBlacklist
     * const ticketBlacklist = await prisma.ticketBlacklist.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketBlacklistUpdateArgs>(args: SelectSubset<T, TicketBlacklistUpdateArgs<ExtArgs>>): Prisma__TicketBlacklistClient<$Result.GetResult<Prisma.$TicketBlacklistPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TicketBlacklists.
     * @param {TicketBlacklistDeleteManyArgs} args - Arguments to filter TicketBlacklists to delete.
     * @example
     * // Delete a few TicketBlacklists
     * const { count } = await prisma.ticketBlacklist.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketBlacklistDeleteManyArgs>(args?: SelectSubset<T, TicketBlacklistDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketBlacklists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketBlacklistUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TicketBlacklists
     * const ticketBlacklist = await prisma.ticketBlacklist.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketBlacklistUpdateManyArgs>(args: SelectSubset<T, TicketBlacklistUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketBlacklists and returns the data updated in the database.
     * @param {TicketBlacklistUpdateManyAndReturnArgs} args - Arguments to update many TicketBlacklists.
     * @example
     * // Update many TicketBlacklists
     * const ticketBlacklist = await prisma.ticketBlacklist.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TicketBlacklists and only return the `id`
     * const ticketBlacklistWithIdOnly = await prisma.ticketBlacklist.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TicketBlacklistUpdateManyAndReturnArgs>(args: SelectSubset<T, TicketBlacklistUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketBlacklistPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TicketBlacklist.
     * @param {TicketBlacklistUpsertArgs} args - Arguments to update or create a TicketBlacklist.
     * @example
     * // Update or create a TicketBlacklist
     * const ticketBlacklist = await prisma.ticketBlacklist.upsert({
     *   create: {
     *     // ... data to create a TicketBlacklist
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TicketBlacklist we want to update
     *   }
     * })
     */
    upsert<T extends TicketBlacklistUpsertArgs>(args: SelectSubset<T, TicketBlacklistUpsertArgs<ExtArgs>>): Prisma__TicketBlacklistClient<$Result.GetResult<Prisma.$TicketBlacklistPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TicketBlacklists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketBlacklistCountArgs} args - Arguments to filter TicketBlacklists to count.
     * @example
     * // Count the number of TicketBlacklists
     * const count = await prisma.ticketBlacklist.count({
     *   where: {
     *     // ... the filter for the TicketBlacklists we want to count
     *   }
     * })
    **/
    count<T extends TicketBlacklistCountArgs>(
      args?: Subset<T, TicketBlacklistCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketBlacklistCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TicketBlacklist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketBlacklistAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketBlacklistAggregateArgs>(args: Subset<T, TicketBlacklistAggregateArgs>): Prisma.PrismaPromise<GetTicketBlacklistAggregateType<T>>

    /**
     * Group by TicketBlacklist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketBlacklistGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketBlacklistGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketBlacklistGroupByArgs['orderBy'] }
        : { orderBy?: TicketBlacklistGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketBlacklistGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketBlacklistGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TicketBlacklist model
   */
  readonly fields: TicketBlacklistFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TicketBlacklist.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketBlacklistClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TicketBlacklist model
   */ 
  interface TicketBlacklistFieldRefs {
    readonly id: FieldRef<"TicketBlacklist", 'Int'>
    readonly userId: FieldRef<"TicketBlacklist", 'String'>
    readonly expiresAt: FieldRef<"TicketBlacklist", 'DateTime'>
    readonly createdAt: FieldRef<"TicketBlacklist", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TicketBlacklist findUnique
   */
  export type TicketBlacklistFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketBlacklist
     */
    select?: TicketBlacklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketBlacklist
     */
    omit?: TicketBlacklistOmit<ExtArgs> | null
    /**
     * Filter, which TicketBlacklist to fetch.
     */
    where: TicketBlacklistWhereUniqueInput
  }

  /**
   * TicketBlacklist findUniqueOrThrow
   */
  export type TicketBlacklistFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketBlacklist
     */
    select?: TicketBlacklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketBlacklist
     */
    omit?: TicketBlacklistOmit<ExtArgs> | null
    /**
     * Filter, which TicketBlacklist to fetch.
     */
    where: TicketBlacklistWhereUniqueInput
  }

  /**
   * TicketBlacklist findFirst
   */
  export type TicketBlacklistFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketBlacklist
     */
    select?: TicketBlacklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketBlacklist
     */
    omit?: TicketBlacklistOmit<ExtArgs> | null
    /**
     * Filter, which TicketBlacklist to fetch.
     */
    where?: TicketBlacklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketBlacklists to fetch.
     */
    orderBy?: TicketBlacklistOrderByWithRelationInput | TicketBlacklistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketBlacklists.
     */
    cursor?: TicketBlacklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketBlacklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketBlacklists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketBlacklists.
     */
    distinct?: TicketBlacklistScalarFieldEnum | TicketBlacklistScalarFieldEnum[]
  }

  /**
   * TicketBlacklist findFirstOrThrow
   */
  export type TicketBlacklistFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketBlacklist
     */
    select?: TicketBlacklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketBlacklist
     */
    omit?: TicketBlacklistOmit<ExtArgs> | null
    /**
     * Filter, which TicketBlacklist to fetch.
     */
    where?: TicketBlacklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketBlacklists to fetch.
     */
    orderBy?: TicketBlacklistOrderByWithRelationInput | TicketBlacklistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketBlacklists.
     */
    cursor?: TicketBlacklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketBlacklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketBlacklists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketBlacklists.
     */
    distinct?: TicketBlacklistScalarFieldEnum | TicketBlacklistScalarFieldEnum[]
  }

  /**
   * TicketBlacklist findMany
   */
  export type TicketBlacklistFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketBlacklist
     */
    select?: TicketBlacklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketBlacklist
     */
    omit?: TicketBlacklistOmit<ExtArgs> | null
    /**
     * Filter, which TicketBlacklists to fetch.
     */
    where?: TicketBlacklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketBlacklists to fetch.
     */
    orderBy?: TicketBlacklistOrderByWithRelationInput | TicketBlacklistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TicketBlacklists.
     */
    cursor?: TicketBlacklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketBlacklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketBlacklists.
     */
    skip?: number
    distinct?: TicketBlacklistScalarFieldEnum | TicketBlacklistScalarFieldEnum[]
  }

  /**
   * TicketBlacklist create
   */
  export type TicketBlacklistCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketBlacklist
     */
    select?: TicketBlacklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketBlacklist
     */
    omit?: TicketBlacklistOmit<ExtArgs> | null
    /**
     * The data needed to create a TicketBlacklist.
     */
    data: XOR<TicketBlacklistCreateInput, TicketBlacklistUncheckedCreateInput>
  }

  /**
   * TicketBlacklist createMany
   */
  export type TicketBlacklistCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TicketBlacklists.
     */
    data: TicketBlacklistCreateManyInput | TicketBlacklistCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TicketBlacklist createManyAndReturn
   */
  export type TicketBlacklistCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketBlacklist
     */
    select?: TicketBlacklistSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TicketBlacklist
     */
    omit?: TicketBlacklistOmit<ExtArgs> | null
    /**
     * The data used to create many TicketBlacklists.
     */
    data: TicketBlacklistCreateManyInput | TicketBlacklistCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TicketBlacklist update
   */
  export type TicketBlacklistUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketBlacklist
     */
    select?: TicketBlacklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketBlacklist
     */
    omit?: TicketBlacklistOmit<ExtArgs> | null
    /**
     * The data needed to update a TicketBlacklist.
     */
    data: XOR<TicketBlacklistUpdateInput, TicketBlacklistUncheckedUpdateInput>
    /**
     * Choose, which TicketBlacklist to update.
     */
    where: TicketBlacklistWhereUniqueInput
  }

  /**
   * TicketBlacklist updateMany
   */
  export type TicketBlacklistUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TicketBlacklists.
     */
    data: XOR<TicketBlacklistUpdateManyMutationInput, TicketBlacklistUncheckedUpdateManyInput>
    /**
     * Filter which TicketBlacklists to update
     */
    where?: TicketBlacklistWhereInput
    /**
     * Limit how many TicketBlacklists to update.
     */
    limit?: number
  }

  /**
   * TicketBlacklist updateManyAndReturn
   */
  export type TicketBlacklistUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketBlacklist
     */
    select?: TicketBlacklistSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TicketBlacklist
     */
    omit?: TicketBlacklistOmit<ExtArgs> | null
    /**
     * The data used to update TicketBlacklists.
     */
    data: XOR<TicketBlacklistUpdateManyMutationInput, TicketBlacklistUncheckedUpdateManyInput>
    /**
     * Filter which TicketBlacklists to update
     */
    where?: TicketBlacklistWhereInput
    /**
     * Limit how many TicketBlacklists to update.
     */
    limit?: number
  }

  /**
   * TicketBlacklist upsert
   */
  export type TicketBlacklistUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketBlacklist
     */
    select?: TicketBlacklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketBlacklist
     */
    omit?: TicketBlacklistOmit<ExtArgs> | null
    /**
     * The filter to search for the TicketBlacklist to update in case it exists.
     */
    where: TicketBlacklistWhereUniqueInput
    /**
     * In case the TicketBlacklist found by the `where` argument doesn't exist, create a new TicketBlacklist with this data.
     */
    create: XOR<TicketBlacklistCreateInput, TicketBlacklistUncheckedCreateInput>
    /**
     * In case the TicketBlacklist was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketBlacklistUpdateInput, TicketBlacklistUncheckedUpdateInput>
  }

  /**
   * TicketBlacklist delete
   */
  export type TicketBlacklistDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketBlacklist
     */
    select?: TicketBlacklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketBlacklist
     */
    omit?: TicketBlacklistOmit<ExtArgs> | null
    /**
     * Filter which TicketBlacklist to delete.
     */
    where: TicketBlacklistWhereUniqueInput
  }

  /**
   * TicketBlacklist deleteMany
   */
  export type TicketBlacklistDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketBlacklists to delete
     */
    where?: TicketBlacklistWhereInput
    /**
     * Limit how many TicketBlacklists to delete.
     */
    limit?: number
  }

  /**
   * TicketBlacklist without action
   */
  export type TicketBlacklistDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketBlacklist
     */
    select?: TicketBlacklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketBlacklist
     */
    omit?: TicketBlacklistOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TicketScalarFieldEnum: {
    id: 'id',
    ticketNumber: 'ticketNumber',
    ticketType: 'ticketType',
    status: 'status',
    channelId: 'channelId',
    userId: 'userId',
    ticketMessageId: 'ticketMessageId',
    reason: 'reason',
    reportedUser: 'reportedUser',
    inviteLink: 'inviteLink',
    proofUrls: 'proofUrls',
    transcriptUrl: 'transcriptUrl',
    lastMessageAt: 'lastMessageAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    added_user: 'added_user',
    added_roles: 'added_roles',
    duration: 'duration',
    outsideMessageId: 'outsideMessageId'
  };

  export type TicketScalarFieldEnum = (typeof TicketScalarFieldEnum)[keyof typeof TicketScalarFieldEnum]


  export const TicketSettingsScalarFieldEnum: {
    id: 'id',
    ticketCounter: 'ticketCounter'
  };

  export type TicketSettingsScalarFieldEnum = (typeof TicketSettingsScalarFieldEnum)[keyof typeof TicketSettingsScalarFieldEnum]


  export const PlayerProfileScalarFieldEnum: {
    id: 'id',
    discordUserId: 'discordUserId',
    ign: 'ign',
    lastSeen: 'lastSeen',
    ranks: 'ranks',
    clanName: 'clanName',
    rankInfo: 'rankInfo',
    friends: 'friends',
    createdAt: 'createdAt'
  };

  export type PlayerProfileScalarFieldEnum = (typeof PlayerProfileScalarFieldEnum)[keyof typeof PlayerProfileScalarFieldEnum]


  export const TicketConfigScalarFieldEnum: {
    id: 'id',
    ticketType: 'ticketType',
    permissions: 'permissions',
    allowCustomInstructions: 'allowCustomInstructions',
    useCustomInstructions: 'useCustomInstructions',
    instructions: 'instructions',
    previewTitle: 'previewTitle'
  };

  export type TicketConfigScalarFieldEnum = (typeof TicketConfigScalarFieldEnum)[keyof typeof TicketConfigScalarFieldEnum]


  export const TicketBlacklistScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type TicketBlacklistScalarFieldEnum = (typeof TicketBlacklistScalarFieldEnum)[keyof typeof TicketBlacklistScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type TicketWhereInput = {
    AND?: TicketWhereInput | TicketWhereInput[]
    OR?: TicketWhereInput[]
    NOT?: TicketWhereInput | TicketWhereInput[]
    id?: IntFilter<"Ticket"> | number
    ticketNumber?: IntFilter<"Ticket"> | number
    ticketType?: StringFilter<"Ticket"> | string
    status?: StringFilter<"Ticket"> | string
    channelId?: StringFilter<"Ticket"> | string
    userId?: StringFilter<"Ticket"> | string
    ticketMessageId?: StringNullableFilter<"Ticket"> | string | null
    reason?: StringNullableFilter<"Ticket"> | string | null
    reportedUser?: StringNullableFilter<"Ticket"> | string | null
    inviteLink?: StringNullableFilter<"Ticket"> | string | null
    proofUrls?: JsonNullableFilter<"Ticket">
    transcriptUrl?: StringNullableFilter<"Ticket"> | string | null
    lastMessageAt?: DateTimeNullableFilter<"Ticket"> | Date | string | null
    createdAt?: DateTimeFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeFilter<"Ticket"> | Date | string
    added_user?: JsonNullableFilter<"Ticket">
    added_roles?: JsonNullableFilter<"Ticket">
    duration?: IntNullableFilter<"Ticket"> | number | null
    outsideMessageId?: StringNullableFilter<"Ticket"> | string | null
  }

  export type TicketOrderByWithRelationInput = {
    id?: SortOrder
    ticketNumber?: SortOrder
    ticketType?: SortOrder
    status?: SortOrder
    channelId?: SortOrder
    userId?: SortOrder
    ticketMessageId?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    reportedUser?: SortOrderInput | SortOrder
    inviteLink?: SortOrderInput | SortOrder
    proofUrls?: SortOrderInput | SortOrder
    transcriptUrl?: SortOrderInput | SortOrder
    lastMessageAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    added_user?: SortOrderInput | SortOrder
    added_roles?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    outsideMessageId?: SortOrderInput | SortOrder
  }

  export type TicketWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TicketWhereInput | TicketWhereInput[]
    OR?: TicketWhereInput[]
    NOT?: TicketWhereInput | TicketWhereInput[]
    ticketNumber?: IntFilter<"Ticket"> | number
    ticketType?: StringFilter<"Ticket"> | string
    status?: StringFilter<"Ticket"> | string
    channelId?: StringFilter<"Ticket"> | string
    userId?: StringFilter<"Ticket"> | string
    ticketMessageId?: StringNullableFilter<"Ticket"> | string | null
    reason?: StringNullableFilter<"Ticket"> | string | null
    reportedUser?: StringNullableFilter<"Ticket"> | string | null
    inviteLink?: StringNullableFilter<"Ticket"> | string | null
    proofUrls?: JsonNullableFilter<"Ticket">
    transcriptUrl?: StringNullableFilter<"Ticket"> | string | null
    lastMessageAt?: DateTimeNullableFilter<"Ticket"> | Date | string | null
    createdAt?: DateTimeFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeFilter<"Ticket"> | Date | string
    added_user?: JsonNullableFilter<"Ticket">
    added_roles?: JsonNullableFilter<"Ticket">
    duration?: IntNullableFilter<"Ticket"> | number | null
    outsideMessageId?: StringNullableFilter<"Ticket"> | string | null
  }, "id">

  export type TicketOrderByWithAggregationInput = {
    id?: SortOrder
    ticketNumber?: SortOrder
    ticketType?: SortOrder
    status?: SortOrder
    channelId?: SortOrder
    userId?: SortOrder
    ticketMessageId?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    reportedUser?: SortOrderInput | SortOrder
    inviteLink?: SortOrderInput | SortOrder
    proofUrls?: SortOrderInput | SortOrder
    transcriptUrl?: SortOrderInput | SortOrder
    lastMessageAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    added_user?: SortOrderInput | SortOrder
    added_roles?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    outsideMessageId?: SortOrderInput | SortOrder
    _count?: TicketCountOrderByAggregateInput
    _avg?: TicketAvgOrderByAggregateInput
    _max?: TicketMaxOrderByAggregateInput
    _min?: TicketMinOrderByAggregateInput
    _sum?: TicketSumOrderByAggregateInput
  }

  export type TicketScalarWhereWithAggregatesInput = {
    AND?: TicketScalarWhereWithAggregatesInput | TicketScalarWhereWithAggregatesInput[]
    OR?: TicketScalarWhereWithAggregatesInput[]
    NOT?: TicketScalarWhereWithAggregatesInput | TicketScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Ticket"> | number
    ticketNumber?: IntWithAggregatesFilter<"Ticket"> | number
    ticketType?: StringWithAggregatesFilter<"Ticket"> | string
    status?: StringWithAggregatesFilter<"Ticket"> | string
    channelId?: StringWithAggregatesFilter<"Ticket"> | string
    userId?: StringWithAggregatesFilter<"Ticket"> | string
    ticketMessageId?: StringNullableWithAggregatesFilter<"Ticket"> | string | null
    reason?: StringNullableWithAggregatesFilter<"Ticket"> | string | null
    reportedUser?: StringNullableWithAggregatesFilter<"Ticket"> | string | null
    inviteLink?: StringNullableWithAggregatesFilter<"Ticket"> | string | null
    proofUrls?: JsonNullableWithAggregatesFilter<"Ticket">
    transcriptUrl?: StringNullableWithAggregatesFilter<"Ticket"> | string | null
    lastMessageAt?: DateTimeNullableWithAggregatesFilter<"Ticket"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Ticket"> | Date | string
    added_user?: JsonNullableWithAggregatesFilter<"Ticket">
    added_roles?: JsonNullableWithAggregatesFilter<"Ticket">
    duration?: IntNullableWithAggregatesFilter<"Ticket"> | number | null
    outsideMessageId?: StringNullableWithAggregatesFilter<"Ticket"> | string | null
  }

  export type TicketSettingsWhereInput = {
    AND?: TicketSettingsWhereInput | TicketSettingsWhereInput[]
    OR?: TicketSettingsWhereInput[]
    NOT?: TicketSettingsWhereInput | TicketSettingsWhereInput[]
    id?: IntFilter<"TicketSettings"> | number
    ticketCounter?: IntFilter<"TicketSettings"> | number
  }

  export type TicketSettingsOrderByWithRelationInput = {
    id?: SortOrder
    ticketCounter?: SortOrder
  }

  export type TicketSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TicketSettingsWhereInput | TicketSettingsWhereInput[]
    OR?: TicketSettingsWhereInput[]
    NOT?: TicketSettingsWhereInput | TicketSettingsWhereInput[]
    ticketCounter?: IntFilter<"TicketSettings"> | number
  }, "id">

  export type TicketSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    ticketCounter?: SortOrder
    _count?: TicketSettingsCountOrderByAggregateInput
    _avg?: TicketSettingsAvgOrderByAggregateInput
    _max?: TicketSettingsMaxOrderByAggregateInput
    _min?: TicketSettingsMinOrderByAggregateInput
    _sum?: TicketSettingsSumOrderByAggregateInput
  }

  export type TicketSettingsScalarWhereWithAggregatesInput = {
    AND?: TicketSettingsScalarWhereWithAggregatesInput | TicketSettingsScalarWhereWithAggregatesInput[]
    OR?: TicketSettingsScalarWhereWithAggregatesInput[]
    NOT?: TicketSettingsScalarWhereWithAggregatesInput | TicketSettingsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TicketSettings"> | number
    ticketCounter?: IntWithAggregatesFilter<"TicketSettings"> | number
  }

  export type PlayerProfileWhereInput = {
    AND?: PlayerProfileWhereInput | PlayerProfileWhereInput[]
    OR?: PlayerProfileWhereInput[]
    NOT?: PlayerProfileWhereInput | PlayerProfileWhereInput[]
    id?: IntFilter<"PlayerProfile"> | number
    discordUserId?: StringFilter<"PlayerProfile"> | string
    ign?: StringFilter<"PlayerProfile"> | string
    lastSeen?: DateTimeNullableFilter<"PlayerProfile"> | Date | string | null
    ranks?: JsonNullableFilter<"PlayerProfile">
    clanName?: StringNullableFilter<"PlayerProfile"> | string | null
    rankInfo?: JsonNullableFilter<"PlayerProfile">
    friends?: JsonNullableFilter<"PlayerProfile">
    createdAt?: DateTimeFilter<"PlayerProfile"> | Date | string
  }

  export type PlayerProfileOrderByWithRelationInput = {
    id?: SortOrder
    discordUserId?: SortOrder
    ign?: SortOrder
    lastSeen?: SortOrderInput | SortOrder
    ranks?: SortOrderInput | SortOrder
    clanName?: SortOrderInput | SortOrder
    rankInfo?: SortOrderInput | SortOrder
    friends?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type PlayerProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    discordUserId?: string
    AND?: PlayerProfileWhereInput | PlayerProfileWhereInput[]
    OR?: PlayerProfileWhereInput[]
    NOT?: PlayerProfileWhereInput | PlayerProfileWhereInput[]
    ign?: StringFilter<"PlayerProfile"> | string
    lastSeen?: DateTimeNullableFilter<"PlayerProfile"> | Date | string | null
    ranks?: JsonNullableFilter<"PlayerProfile">
    clanName?: StringNullableFilter<"PlayerProfile"> | string | null
    rankInfo?: JsonNullableFilter<"PlayerProfile">
    friends?: JsonNullableFilter<"PlayerProfile">
    createdAt?: DateTimeFilter<"PlayerProfile"> | Date | string
  }, "id" | "discordUserId">

  export type PlayerProfileOrderByWithAggregationInput = {
    id?: SortOrder
    discordUserId?: SortOrder
    ign?: SortOrder
    lastSeen?: SortOrderInput | SortOrder
    ranks?: SortOrderInput | SortOrder
    clanName?: SortOrderInput | SortOrder
    rankInfo?: SortOrderInput | SortOrder
    friends?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PlayerProfileCountOrderByAggregateInput
    _avg?: PlayerProfileAvgOrderByAggregateInput
    _max?: PlayerProfileMaxOrderByAggregateInput
    _min?: PlayerProfileMinOrderByAggregateInput
    _sum?: PlayerProfileSumOrderByAggregateInput
  }

  export type PlayerProfileScalarWhereWithAggregatesInput = {
    AND?: PlayerProfileScalarWhereWithAggregatesInput | PlayerProfileScalarWhereWithAggregatesInput[]
    OR?: PlayerProfileScalarWhereWithAggregatesInput[]
    NOT?: PlayerProfileScalarWhereWithAggregatesInput | PlayerProfileScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PlayerProfile"> | number
    discordUserId?: StringWithAggregatesFilter<"PlayerProfile"> | string
    ign?: StringWithAggregatesFilter<"PlayerProfile"> | string
    lastSeen?: DateTimeNullableWithAggregatesFilter<"PlayerProfile"> | Date | string | null
    ranks?: JsonNullableWithAggregatesFilter<"PlayerProfile">
    clanName?: StringNullableWithAggregatesFilter<"PlayerProfile"> | string | null
    rankInfo?: JsonNullableWithAggregatesFilter<"PlayerProfile">
    friends?: JsonNullableWithAggregatesFilter<"PlayerProfile">
    createdAt?: DateTimeWithAggregatesFilter<"PlayerProfile"> | Date | string
  }

  export type TicketConfigWhereInput = {
    AND?: TicketConfigWhereInput | TicketConfigWhereInput[]
    OR?: TicketConfigWhereInput[]
    NOT?: TicketConfigWhereInput | TicketConfigWhereInput[]
    id?: IntFilter<"TicketConfig"> | number
    ticketType?: StringFilter<"TicketConfig"> | string
    permissions?: JsonNullableFilter<"TicketConfig">
    allowCustomInstructions?: BoolFilter<"TicketConfig"> | boolean
    useCustomInstructions?: BoolFilter<"TicketConfig"> | boolean
    instructions?: StringNullableFilter<"TicketConfig"> | string | null
    previewTitle?: StringNullableFilter<"TicketConfig"> | string | null
  }

  export type TicketConfigOrderByWithRelationInput = {
    id?: SortOrder
    ticketType?: SortOrder
    permissions?: SortOrderInput | SortOrder
    allowCustomInstructions?: SortOrder
    useCustomInstructions?: SortOrder
    instructions?: SortOrderInput | SortOrder
    previewTitle?: SortOrderInput | SortOrder
  }

  export type TicketConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    ticketType?: string
    AND?: TicketConfigWhereInput | TicketConfigWhereInput[]
    OR?: TicketConfigWhereInput[]
    NOT?: TicketConfigWhereInput | TicketConfigWhereInput[]
    permissions?: JsonNullableFilter<"TicketConfig">
    allowCustomInstructions?: BoolFilter<"TicketConfig"> | boolean
    useCustomInstructions?: BoolFilter<"TicketConfig"> | boolean
    instructions?: StringNullableFilter<"TicketConfig"> | string | null
    previewTitle?: StringNullableFilter<"TicketConfig"> | string | null
  }, "id" | "ticketType">

  export type TicketConfigOrderByWithAggregationInput = {
    id?: SortOrder
    ticketType?: SortOrder
    permissions?: SortOrderInput | SortOrder
    allowCustomInstructions?: SortOrder
    useCustomInstructions?: SortOrder
    instructions?: SortOrderInput | SortOrder
    previewTitle?: SortOrderInput | SortOrder
    _count?: TicketConfigCountOrderByAggregateInput
    _avg?: TicketConfigAvgOrderByAggregateInput
    _max?: TicketConfigMaxOrderByAggregateInput
    _min?: TicketConfigMinOrderByAggregateInput
    _sum?: TicketConfigSumOrderByAggregateInput
  }

  export type TicketConfigScalarWhereWithAggregatesInput = {
    AND?: TicketConfigScalarWhereWithAggregatesInput | TicketConfigScalarWhereWithAggregatesInput[]
    OR?: TicketConfigScalarWhereWithAggregatesInput[]
    NOT?: TicketConfigScalarWhereWithAggregatesInput | TicketConfigScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TicketConfig"> | number
    ticketType?: StringWithAggregatesFilter<"TicketConfig"> | string
    permissions?: JsonNullableWithAggregatesFilter<"TicketConfig">
    allowCustomInstructions?: BoolWithAggregatesFilter<"TicketConfig"> | boolean
    useCustomInstructions?: BoolWithAggregatesFilter<"TicketConfig"> | boolean
    instructions?: StringNullableWithAggregatesFilter<"TicketConfig"> | string | null
    previewTitle?: StringNullableWithAggregatesFilter<"TicketConfig"> | string | null
  }

  export type TicketBlacklistWhereInput = {
    AND?: TicketBlacklistWhereInput | TicketBlacklistWhereInput[]
    OR?: TicketBlacklistWhereInput[]
    NOT?: TicketBlacklistWhereInput | TicketBlacklistWhereInput[]
    id?: IntFilter<"TicketBlacklist"> | number
    userId?: StringFilter<"TicketBlacklist"> | string
    expiresAt?: DateTimeNullableFilter<"TicketBlacklist"> | Date | string | null
    createdAt?: DateTimeFilter<"TicketBlacklist"> | Date | string
  }

  export type TicketBlacklistOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type TicketBlacklistWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: string
    AND?: TicketBlacklistWhereInput | TicketBlacklistWhereInput[]
    OR?: TicketBlacklistWhereInput[]
    NOT?: TicketBlacklistWhereInput | TicketBlacklistWhereInput[]
    expiresAt?: DateTimeNullableFilter<"TicketBlacklist"> | Date | string | null
    createdAt?: DateTimeFilter<"TicketBlacklist"> | Date | string
  }, "id" | "userId">

  export type TicketBlacklistOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: TicketBlacklistCountOrderByAggregateInput
    _avg?: TicketBlacklistAvgOrderByAggregateInput
    _max?: TicketBlacklistMaxOrderByAggregateInput
    _min?: TicketBlacklistMinOrderByAggregateInput
    _sum?: TicketBlacklistSumOrderByAggregateInput
  }

  export type TicketBlacklistScalarWhereWithAggregatesInput = {
    AND?: TicketBlacklistScalarWhereWithAggregatesInput | TicketBlacklistScalarWhereWithAggregatesInput[]
    OR?: TicketBlacklistScalarWhereWithAggregatesInput[]
    NOT?: TicketBlacklistScalarWhereWithAggregatesInput | TicketBlacklistScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TicketBlacklist"> | number
    userId?: StringWithAggregatesFilter<"TicketBlacklist"> | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"TicketBlacklist"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TicketBlacklist"> | Date | string
  }

  export type TicketCreateInput = {
    ticketNumber: number
    ticketType: string
    status: string
    channelId: string
    userId: string
    ticketMessageId?: string | null
    reason?: string | null
    reportedUser?: string | null
    inviteLink?: string | null
    proofUrls?: NullableJsonNullValueInput | InputJsonValue
    transcriptUrl?: string | null
    lastMessageAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    added_user?: NullableJsonNullValueInput | InputJsonValue
    added_roles?: NullableJsonNullValueInput | InputJsonValue
    duration?: number | null
    outsideMessageId?: string | null
  }

  export type TicketUncheckedCreateInput = {
    id?: number
    ticketNumber: number
    ticketType: string
    status: string
    channelId: string
    userId: string
    ticketMessageId?: string | null
    reason?: string | null
    reportedUser?: string | null
    inviteLink?: string | null
    proofUrls?: NullableJsonNullValueInput | InputJsonValue
    transcriptUrl?: string | null
    lastMessageAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    added_user?: NullableJsonNullValueInput | InputJsonValue
    added_roles?: NullableJsonNullValueInput | InputJsonValue
    duration?: number | null
    outsideMessageId?: string | null
  }

  export type TicketUpdateInput = {
    ticketNumber?: IntFieldUpdateOperationsInput | number
    ticketType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    ticketMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    reportedUser?: NullableStringFieldUpdateOperationsInput | string | null
    inviteLink?: NullableStringFieldUpdateOperationsInput | string | null
    proofUrls?: NullableJsonNullValueInput | InputJsonValue
    transcriptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    added_user?: NullableJsonNullValueInput | InputJsonValue
    added_roles?: NullableJsonNullValueInput | InputJsonValue
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    outsideMessageId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TicketUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticketNumber?: IntFieldUpdateOperationsInput | number
    ticketType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    ticketMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    reportedUser?: NullableStringFieldUpdateOperationsInput | string | null
    inviteLink?: NullableStringFieldUpdateOperationsInput | string | null
    proofUrls?: NullableJsonNullValueInput | InputJsonValue
    transcriptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    added_user?: NullableJsonNullValueInput | InputJsonValue
    added_roles?: NullableJsonNullValueInput | InputJsonValue
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    outsideMessageId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TicketCreateManyInput = {
    id?: number
    ticketNumber: number
    ticketType: string
    status: string
    channelId: string
    userId: string
    ticketMessageId?: string | null
    reason?: string | null
    reportedUser?: string | null
    inviteLink?: string | null
    proofUrls?: NullableJsonNullValueInput | InputJsonValue
    transcriptUrl?: string | null
    lastMessageAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    added_user?: NullableJsonNullValueInput | InputJsonValue
    added_roles?: NullableJsonNullValueInput | InputJsonValue
    duration?: number | null
    outsideMessageId?: string | null
  }

  export type TicketUpdateManyMutationInput = {
    ticketNumber?: IntFieldUpdateOperationsInput | number
    ticketType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    ticketMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    reportedUser?: NullableStringFieldUpdateOperationsInput | string | null
    inviteLink?: NullableStringFieldUpdateOperationsInput | string | null
    proofUrls?: NullableJsonNullValueInput | InputJsonValue
    transcriptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    added_user?: NullableJsonNullValueInput | InputJsonValue
    added_roles?: NullableJsonNullValueInput | InputJsonValue
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    outsideMessageId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TicketUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticketNumber?: IntFieldUpdateOperationsInput | number
    ticketType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    ticketMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    reportedUser?: NullableStringFieldUpdateOperationsInput | string | null
    inviteLink?: NullableStringFieldUpdateOperationsInput | string | null
    proofUrls?: NullableJsonNullValueInput | InputJsonValue
    transcriptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    added_user?: NullableJsonNullValueInput | InputJsonValue
    added_roles?: NullableJsonNullValueInput | InputJsonValue
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    outsideMessageId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TicketSettingsCreateInput = {
    id?: number
    ticketCounter: number
  }

  export type TicketSettingsUncheckedCreateInput = {
    id?: number
    ticketCounter: number
  }

  export type TicketSettingsUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticketCounter?: IntFieldUpdateOperationsInput | number
  }

  export type TicketSettingsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticketCounter?: IntFieldUpdateOperationsInput | number
  }

  export type TicketSettingsCreateManyInput = {
    id?: number
    ticketCounter: number
  }

  export type TicketSettingsUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticketCounter?: IntFieldUpdateOperationsInput | number
  }

  export type TicketSettingsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticketCounter?: IntFieldUpdateOperationsInput | number
  }

  export type PlayerProfileCreateInput = {
    discordUserId: string
    ign: string
    lastSeen?: Date | string | null
    ranks?: NullableJsonNullValueInput | InputJsonValue
    clanName?: string | null
    rankInfo?: NullableJsonNullValueInput | InputJsonValue
    friends?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PlayerProfileUncheckedCreateInput = {
    id?: number
    discordUserId: string
    ign: string
    lastSeen?: Date | string | null
    ranks?: NullableJsonNullValueInput | InputJsonValue
    clanName?: string | null
    rankInfo?: NullableJsonNullValueInput | InputJsonValue
    friends?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PlayerProfileUpdateInput = {
    discordUserId?: StringFieldUpdateOperationsInput | string
    ign?: StringFieldUpdateOperationsInput | string
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ranks?: NullableJsonNullValueInput | InputJsonValue
    clanName?: NullableStringFieldUpdateOperationsInput | string | null
    rankInfo?: NullableJsonNullValueInput | InputJsonValue
    friends?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerProfileUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    discordUserId?: StringFieldUpdateOperationsInput | string
    ign?: StringFieldUpdateOperationsInput | string
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ranks?: NullableJsonNullValueInput | InputJsonValue
    clanName?: NullableStringFieldUpdateOperationsInput | string | null
    rankInfo?: NullableJsonNullValueInput | InputJsonValue
    friends?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerProfileCreateManyInput = {
    id?: number
    discordUserId: string
    ign: string
    lastSeen?: Date | string | null
    ranks?: NullableJsonNullValueInput | InputJsonValue
    clanName?: string | null
    rankInfo?: NullableJsonNullValueInput | InputJsonValue
    friends?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PlayerProfileUpdateManyMutationInput = {
    discordUserId?: StringFieldUpdateOperationsInput | string
    ign?: StringFieldUpdateOperationsInput | string
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ranks?: NullableJsonNullValueInput | InputJsonValue
    clanName?: NullableStringFieldUpdateOperationsInput | string | null
    rankInfo?: NullableJsonNullValueInput | InputJsonValue
    friends?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerProfileUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    discordUserId?: StringFieldUpdateOperationsInput | string
    ign?: StringFieldUpdateOperationsInput | string
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ranks?: NullableJsonNullValueInput | InputJsonValue
    clanName?: NullableStringFieldUpdateOperationsInput | string | null
    rankInfo?: NullableJsonNullValueInput | InputJsonValue
    friends?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketConfigCreateInput = {
    ticketType: string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    allowCustomInstructions?: boolean
    useCustomInstructions?: boolean
    instructions?: string | null
    previewTitle?: string | null
  }

  export type TicketConfigUncheckedCreateInput = {
    id?: number
    ticketType: string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    allowCustomInstructions?: boolean
    useCustomInstructions?: boolean
    instructions?: string | null
    previewTitle?: string | null
  }

  export type TicketConfigUpdateInput = {
    ticketType?: StringFieldUpdateOperationsInput | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    allowCustomInstructions?: BoolFieldUpdateOperationsInput | boolean
    useCustomInstructions?: BoolFieldUpdateOperationsInput | boolean
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    previewTitle?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TicketConfigUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticketType?: StringFieldUpdateOperationsInput | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    allowCustomInstructions?: BoolFieldUpdateOperationsInput | boolean
    useCustomInstructions?: BoolFieldUpdateOperationsInput | boolean
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    previewTitle?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TicketConfigCreateManyInput = {
    id?: number
    ticketType: string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    allowCustomInstructions?: boolean
    useCustomInstructions?: boolean
    instructions?: string | null
    previewTitle?: string | null
  }

  export type TicketConfigUpdateManyMutationInput = {
    ticketType?: StringFieldUpdateOperationsInput | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    allowCustomInstructions?: BoolFieldUpdateOperationsInput | boolean
    useCustomInstructions?: BoolFieldUpdateOperationsInput | boolean
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    previewTitle?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TicketConfigUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticketType?: StringFieldUpdateOperationsInput | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    allowCustomInstructions?: BoolFieldUpdateOperationsInput | boolean
    useCustomInstructions?: BoolFieldUpdateOperationsInput | boolean
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    previewTitle?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TicketBlacklistCreateInput = {
    userId: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type TicketBlacklistUncheckedCreateInput = {
    id?: number
    userId: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type TicketBlacklistUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketBlacklistUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketBlacklistCreateManyInput = {
    id?: number
    userId: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type TicketBlacklistUpdateManyMutationInput = {
    userId?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketBlacklistUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type TicketCountOrderByAggregateInput = {
    id?: SortOrder
    ticketNumber?: SortOrder
    ticketType?: SortOrder
    status?: SortOrder
    channelId?: SortOrder
    userId?: SortOrder
    ticketMessageId?: SortOrder
    reason?: SortOrder
    reportedUser?: SortOrder
    inviteLink?: SortOrder
    proofUrls?: SortOrder
    transcriptUrl?: SortOrder
    lastMessageAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    added_user?: SortOrder
    added_roles?: SortOrder
    duration?: SortOrder
    outsideMessageId?: SortOrder
  }

  export type TicketAvgOrderByAggregateInput = {
    id?: SortOrder
    ticketNumber?: SortOrder
    duration?: SortOrder
  }

  export type TicketMaxOrderByAggregateInput = {
    id?: SortOrder
    ticketNumber?: SortOrder
    ticketType?: SortOrder
    status?: SortOrder
    channelId?: SortOrder
    userId?: SortOrder
    ticketMessageId?: SortOrder
    reason?: SortOrder
    reportedUser?: SortOrder
    inviteLink?: SortOrder
    transcriptUrl?: SortOrder
    lastMessageAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    duration?: SortOrder
    outsideMessageId?: SortOrder
  }

  export type TicketMinOrderByAggregateInput = {
    id?: SortOrder
    ticketNumber?: SortOrder
    ticketType?: SortOrder
    status?: SortOrder
    channelId?: SortOrder
    userId?: SortOrder
    ticketMessageId?: SortOrder
    reason?: SortOrder
    reportedUser?: SortOrder
    inviteLink?: SortOrder
    transcriptUrl?: SortOrder
    lastMessageAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    duration?: SortOrder
    outsideMessageId?: SortOrder
  }

  export type TicketSumOrderByAggregateInput = {
    id?: SortOrder
    ticketNumber?: SortOrder
    duration?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type TicketSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    ticketCounter?: SortOrder
  }

  export type TicketSettingsAvgOrderByAggregateInput = {
    id?: SortOrder
    ticketCounter?: SortOrder
  }

  export type TicketSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    ticketCounter?: SortOrder
  }

  export type TicketSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    ticketCounter?: SortOrder
  }

  export type TicketSettingsSumOrderByAggregateInput = {
    id?: SortOrder
    ticketCounter?: SortOrder
  }

  export type PlayerProfileCountOrderByAggregateInput = {
    id?: SortOrder
    discordUserId?: SortOrder
    ign?: SortOrder
    lastSeen?: SortOrder
    ranks?: SortOrder
    clanName?: SortOrder
    rankInfo?: SortOrder
    friends?: SortOrder
    createdAt?: SortOrder
  }

  export type PlayerProfileAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PlayerProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    discordUserId?: SortOrder
    ign?: SortOrder
    lastSeen?: SortOrder
    clanName?: SortOrder
    createdAt?: SortOrder
  }

  export type PlayerProfileMinOrderByAggregateInput = {
    id?: SortOrder
    discordUserId?: SortOrder
    ign?: SortOrder
    lastSeen?: SortOrder
    clanName?: SortOrder
    createdAt?: SortOrder
  }

  export type PlayerProfileSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type TicketConfigCountOrderByAggregateInput = {
    id?: SortOrder
    ticketType?: SortOrder
    permissions?: SortOrder
    allowCustomInstructions?: SortOrder
    useCustomInstructions?: SortOrder
    instructions?: SortOrder
    previewTitle?: SortOrder
  }

  export type TicketConfigAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TicketConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    ticketType?: SortOrder
    allowCustomInstructions?: SortOrder
    useCustomInstructions?: SortOrder
    instructions?: SortOrder
    previewTitle?: SortOrder
  }

  export type TicketConfigMinOrderByAggregateInput = {
    id?: SortOrder
    ticketType?: SortOrder
    allowCustomInstructions?: SortOrder
    useCustomInstructions?: SortOrder
    instructions?: SortOrder
    previewTitle?: SortOrder
  }

  export type TicketConfigSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type TicketBlacklistCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type TicketBlacklistAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TicketBlacklistMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type TicketBlacklistMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type TicketBlacklistSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}